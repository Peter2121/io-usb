<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>

<!-- CSS -->
<title>Module libusb</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #2d2d2d;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 80%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 10px 25px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: block;
  padding: 9.5px;
  margin: 0 10px 10px 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow: visible;
  overflow-x: auto;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: scroll;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */
ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
</style>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Module libusb</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#timeval"
    title="timeval = object 
  tv_sec*: clong
  tv_usec*: clong"><wbr />timeval</a></li>
  <li><a class="reference" href="#libusb_class_code"
    title="libusb_class_code = enum 
  LIBUSB_CLASS_PER_INTERFACE = 0, ## each interface has its own class
  LIBUSB_CLASS_AUDIO = 1,     ## Audio class
  LIBUSB_CLASS_COMM = 2,      ## Communications class
  LIBUSB_CLASS_HID = 3,       ## Human Interface Device class
  LIBUSB_CLASS_PHYSICAL = 5,  ## Physical
  LIBUSB_CLASS_IMAGE = 6,     ## Image class
  LIBUSB_CLASS_PRINTER = 7,   ## Printer class
  LIBUSB_CLASS_MASS_STORAGE = 8, ## Image class
  LIBUSB_CLASS_HUB = 9,       ## Hub class
  LIBUSB_CLASS_DATA = 10,     ## Data class
  LIBUSB_CLASS_SMART_CARD = 0x0000000B, ## Smart Card
  LIBUSB_CLASS_CONTENT_SECURITY = 0x0000000D, ## Content Security
  LIBUSB_CLASS_VIDEO = 0x0000000E, ## Video
  LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0000000F, ## Personal Healthcare
  LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0x000000DC, ## Diagnostic Device
  LIBUSB_CLASS_WIRELESS = 0x000000E0, ## Wireless class
  LIBUSB_CLASS_APPLICATION = 0x000000FE, ## Application class
  LIBUSB_CLASS_VENDOR_SPEC = 0x000000FF ## Class is vendor-specific"><wbr />libusb_<wbr />class_<wbr />code</a></li>
  <li><a class="reference" href="#libusb_descriptor_type"
    title="libusb_descriptor_type = enum 
  LIBUSB_DT_DEVICE = 0x00000001, ## Device descriptor (see `libusb_device_descriptor`)
  LIBUSB_DT_CONFIG = 0x00000002, ## Configuration descriptor (see `libusb_config_descriptor`)
  LIBUSB_DT_STRING = 0x00000003, ## String descriptor
  LIBUSB_DT_INTERFACE = 0x00000004, ## Interface descriptor. See libusb_interface_descriptor
  LIBUSB_DT_ENDPOINT = 0x00000005, ## Endpoint descriptor. See libusb_endpoint_descriptor
  LIBUSB_DT_BOS = 0x0000000F, ## BOS descriptor
  LIBUSB_DT_DEVICE_CAPABILITY = 0x00000010, ## Device Capability descriptor
  LIBUSB_DT_HID = 0x00000021, ## HID descriptor
  LIBUSB_DT_REPORT = 0x00000022, ## HID report descriptor
  LIBUSB_DT_PHYSICAL = 0x00000023, ## Physical descriptor
  LIBUSB_DT_HUB = 0x00000029, ## Hub descriptor
  LIBUSB_DT_SUPERSPEED_HUB = 0x0000002A, ## SuperSpeed Hub descriptor
  LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x00000030 ## SuperSpeed Endpoint Companion descriptor"><wbr />libusb_<wbr />descriptor_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_endpoint_direction"
    title="libusb_endpoint_direction = enum 
  LIBUSB_ENDPOINT_OUT = 0x00000000, ## In: device-to-host
  LIBUSB_ENDPOINT_IN = 0x00000080 ## Out: host-to-device"><wbr />libusb_<wbr />endpoint_<wbr />direction</a></li>
  <li><a class="reference" href="#libusb_transfer_type"
    title="libusb_transfer_type = enum 
  LIBUSB_TRANSFER_TYPE_CONTROL = 0, LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1, ## Isochronous endpoint
  LIBUSB_TRANSFER_TYPE_BULK = 2, ## Bulk endpoint
  LIBUSB_TRANSFER_TYPE_INTERRUPT = 3, ## Interrupt endpoint
  LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4 ## Stream endpoint"><wbr />libusb_<wbr />transfer_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_standard_request"
    title="libusb_standard_request = enum 
  LIBUSB_REQUEST_GET_STATUS = 0x00000000, ## Request status of the specific recipient
  LIBUSB_REQUEST_CLEAR_FEATURE = 0x00000001, ## Clear or disable a specific feature
  LIBUSB_REQUEST_RESERVED2 = 0x00000002, ## Reserved for future use
  LIBUSB_REQUEST_SET_FEATURE = 0x00000003, ## Set or enable a specific feature
  LIBUSB_REQUEST_RESERVED4 = 0x00000004, ## Reserved for future use
  LIBUSB_REQUEST_SET_ADDRESS = 0x00000005, ## Set device address for all future accesses
  LIBUSB_REQUEST_GET_DESCRIPTOR = 0x00000006, ## Get the specified descriptor
  LIBUSB_REQUEST_SET_DESCRIPTOR = 0x00000007, ## Used to update existing \
                                              ## descriptors or add new descriptors
  LIBUSB_REQUEST_GET_CONFIGURATION = 0x00000008, ## Get the current device \
                                                 ## configuration value
  LIBUSB_REQUEST_SET_CONFIGURATION = 0x00000009, ## Set device configuration
  LIBUSB_REQUEST_GET_INTERFACE = 0x0000000A, ## Return the selected \
                                             ## alternate setting for the specified interface
  LIBUSB_REQUEST_SET_INTERFACE = 0x0000000B, ## Select an alternate \
                                             ## interface for the specified interface
  LIBUSB_REQUEST_SYNCH_FRAME = 0x0000000C, ## Set then report an endpoint&#x27;s \
                                           ## synchronization frame
  LIBUSB_REQUEST_SET_SEL = 0x00000030, ## Sets both the U1 and U2 Exit Latency
  LIBUSB_SET_ISOCH_DELAY = 0x00000031 ## Delay from the time a host \
                                      ## transmits a packet to the time it is received by the device"><wbr />libusb_<wbr />standard_<wbr />request</a></li>
  <li><a class="reference" href="#libusb_request_type"
    title="libusb_request_type = enum 
  LIBUSB_REQUEST_TYPE_STANDARD = (0x00000000 shl 5), ## Standard
  LIBUSB_REQUEST_TYPE_CLASS = (0x00000001 shl 5), ## Class
  LIBUSB_REQUEST_TYPE_VENDOR = (0x00000002 shl 5), ## Vendor
  LIBUSB_REQUEST_TYPE_RESERVED = (0x00000003 shl 5) ## Reserved"><wbr />libusb_<wbr />request_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_request_recipient"
    title="libusb_request_recipient = enum 
  LIBUSB_RECIPIENT_DEVICE = 0x00000000, ## Device
  LIBUSB_RECIPIENT_INTERFACE = 0x00000001, ## Interface
  LIBUSB_RECIPIENT_ENDPOINT = 0x00000002, ## Endpoint
  LIBUSB_RECIPIENT_OTHER = 0x00000003 ## Other"><wbr />libusb_<wbr />request_<wbr />recipient</a></li>
  <li><a class="reference" href="#libusb_iso_sync_type"
    title="libusb_iso_sync_type = enum 
  LIBUSB_ISO_SYNC_TYPE_NONE = 0, ## No synchronization
  LIBUSB_ISO_SYNC_TYPE_ASYNC = 1, ## Asynchronous
  LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2, ## Adaptive
  LIBUSB_ISO_SYNC_TYPE_SYNC = 3 ## Synchronous"><wbr />libusb_<wbr />iso_<wbr />sync_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_iso_usage_type"
    title="libusb_iso_usage_type = enum 
  LIBUSB_ISO_USAGE_TYPE_DATA = 0, ## Data endpoint
  LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1, ## Feedback endpoint
  LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2 ## Implicit feedback Data endpoint"><wbr />libusb_<wbr />iso_<wbr />usage_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_device_descriptor"
    title="libusb_device_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes)
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_DEVICE).
  bcdUSB*: uint16 ## USB specification release number in binary-coded \
                  ## decimal. 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc.
  bDeviceClass*: uint8        ## USB-IF class code for the device.
                              ## See `libusb_class_code`.
  bDeviceSubClass*: uint8 ## USB-IF subclass code for the device, qualified \
                          ## by the bDeviceClass value.
  bDeviceProtocol*: uint8 ## USB-IF protocol code for the device, qualified \
                          ## by the bDeviceClass and bDeviceSubClass values.
  bMaxPacketSize0*: uint8     ## Maximum packet size for endpoint 0
  idVendor*: uint16           ## USB-IF vendor ID
  idProduct*: uint16          ## USB-IF product ID
  bcdDevice*: uint16          ## Device release number in binary-coded decimal
  iManufacturer*: uint8       ## Index of string descriptor describing manufacturer
  iProduct*: uint8            ## Index of string descriptor describing product
  iSerialNumber*: uint8       ## Index of string descriptor containing device \
                              ## serial number
  bNumConfigurations*: uint8  ## Number of possible configurations"><wbr />libusb_<wbr />device_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_endpoint_descriptor"
    title="libusb_endpoint_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes).
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_ENDPOINT).
  bEndpointAddress*: uint8 ## The address of the endpoint described by this
                           ## descriptor. Bits 0:3 are the endpoint number. Bits 4:6 are reserved.
                           ## Bit 7 indicates direction, see `libusb_endpoint_direction`.
  bmAttributes*: uint8 ## Attributes which apply to the endpoint when it is
                       ## configured using the bConfigurationValue. Bits 0:1 determine the
                       ## transfer type and correspond to `libusb_transfer_type`. Bits 2:3 are
                       ## only used for isochronous endpoints and correspond to
                       ## `libusb_iso_sync_type`. Bits 4:5 are also only used for isochronous
                       ## endpoints and correspond to `libusb_iso_usage_type1`. Bits 6:7 are
                       ## reserved.
  wMaxPacketSize*: uint16     ## Maximum packet size this endpoint is capable of
                              ## sending&#x2F;receiving.
  bInterval*: uint8           ## Interval for polling endpoint for data transfers.
  bRefresh*: uint8            ## For audio devices only: the rate at which
                              ## synchronization feedback is provided.
  bSynchAddress*: uint8 ## For audio devices only: the address if the synch
                        ## endpoint
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## endpoint descriptors, it will store them here, should you wish to parse
                  ## them.
  extra_length*: cint         ## Length of the extra descriptors, in bytes"><wbr />libusb_<wbr />endpoint_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_interface_descriptor"
    title="libusb_interface_descriptor = object 
  bLength*: uint8
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_INTERFACE).
  bInterfaceNumber*: uint8    ## Number of this interface.
  bAlternateSetting*: uint8   ## Value used to select this alternate setting for
                              ## this interface
  bNumEndpoints*: uint8       ## Number of endpoints used by this interface
                              ## (excluding the control endpoint).
  bInterfaceClass*: uint8     ## USB-IF class code for this interface
                              ## (see `libusb_class_code`)
  bInterfaceSubClass*: uint8  ## USB-IF subclass code for this interface,
                              ## qualified by the bInterfaceClass value.
  bInterfaceProtocol*: uint8  ## USB-IF protocol code for this interface,
                              ## qualified by the bInterfaceClass and bInterfaceSubClass values.
  iInterface*: uint8          ## Index of string descriptor describing this interface.
  endpoint*: ptr libusb_endpoint_descriptor ## Array of endpoint descriptors.
                                            ## This length of this array is determined by the bNumEndpoints field.
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## interface descriptors, it will store them here, should you wish to
                  ## parse them.
  extra_length*: cint         ## Length of the extra descriptors, in bytes."><wbr />libusb_<wbr />interface_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_interface"
    title="libusb_interface = object 
  altsetting*: ptr libusb_interface_descriptor ## Array of interface
                                               ## descriptors. The length of this array is determined by the
                                               ## `num_altsetting` field.
  num_altsetting*: cint       ## The number of alternate settings that belong to
                              ## this interface."><wbr />libusb_<wbr />interface</a></li>
  <li><a class="reference" href="#libusb_config_descriptor"
    title="libusb_config_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes) 
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_CONFIG).
  wTotalLength*: uint16       ## Total length of data returned for this configuration.
  bNumInterfaces*: uint8      ## Number of interfaces supported by this configuration.
  bConfigurationValue*: uint8 ## Identifier value for this configuration.
  iConfiguration*: uint8      ## Index of string descriptor describing this configuration.
  bmAttributes*: uint8        ## Configuration characteristics
  MaxPower*: uint8 ## Maximum power consumption of the USB device from this
                   ## bus in this configuration when the device is fully opreation.
                   ## Expressed in units of 2 mA.
  interfaces*: ptr libusb_interface ## Array of interfaces supported by this
                                    ## configuration. The length of this array is determined by the
                                    ## `bNumInterfaces` field.
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## configuration descriptors, it will store them here, should you wish to
                  ## parse them.
  extra_length*: cint         ## Length of the extra descriptors, in bytes."><wbr />libusb_<wbr />config_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_ss_endpoint_companion_descriptor"
    title="libusb_ss_endpoint_companion_descriptor = object 
  bLength*: uint8             ## Size of this descriptor.
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_SS_ENDPOINT_COMPANION).
  bMaxBurst*: uint8 ## The maximum number of packets the endpoint can send or
                    ## recieve as part of a burst.
  bmAttributes*: uint8 ## In bulk EP: bits 4:0 represents the maximum number
                       ## of streams the EP supports. In isochronous EP: bits 1:0 represents the
                       ## Mult - a zero based value that determines the maximum number of packets
                       ## within a service interval.
  wBytesPerInterval*: uint16  ## The total number of bytes this EP will
                              ## transfer every service interval. valid only for periodic EPs."><wbr />libusb_<wbr />ss_<wbr />endpoint_<wbr />companion_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_bos_dev_capability_descriptor"
    title="libusb_bos_dev_capability_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes) 
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).
  bDevCapabilityType*: uint8  ## Device Capability type.
  dev_capability_data*: array[0, uint8] ## Device Capability data (bLength - 3 bytes)."><wbr />libusb_<wbr />bos_<wbr />dev_<wbr />capability_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_bos_descriptor"
    title="libusb_bos_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes) 
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_BOS).
  wTotalLength*: uint16       ## Length of this descriptor and all of its sub descriptors.
  bNumDeviceCaps*: uint8      ## The number of separate device capability
                              ## descriptors in the BOS.
  dev_capability*: array[0, ptr libusb_bos_dev_capability_descriptor] ## \
                                                                      ## `bNumDeviceCap` Device Capability Descriptors."><wbr />libusb_<wbr />bos_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_usb_2_0_extension_descriptor"
    title="libusb_usb_2_0_extension_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes).
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).
  bDevCapabilityType*: uint8  ## Capability type (LIBUSB_BT_USB_2_0_EXTENSION).
  bmAttributes*: uint32 ## Bitmap encoding of supported device level features.
                        ## A value of one in a bit location indicates a feature is supported; a
                        ## value of zero indicates it is not supported.
                        ## See `libusb_usb_2_0_extension_attributes`."><wbr />libusb_<wbr />usb_<wbr />2_<wbr />0_<wbr />extension_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_ss_usb_device_capability_descriptor"
    title="libusb_ss_usb_device_capability_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes).
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).
  bDevCapabilityType*: uint8  ## Capability type (LIBUSB_BT_SS_USB_DEVICE_CAPABILITY).
  bmAttributes*: uint8 ## Bitmap encoding of supported device level features.
                       ## A value of one in a bit location indicates a feature is supported; a
                       ## value of zero indicates it is not supported.
                       ## See `libusb_ss_usb_device_capability_attributes`.
  wSpeedSupported*: uint16    ## Bitmap encoding of the speed supported by this
                              ## device when operating in SuperSpeed mode. See `libusb_supported_speed`.
  bFunctionalitySupport*: uint8 ## The lowest speed at which all the
                                ## functionality supported by the device is available to the user.
                                ## For example if the device supports all its functionality when connected
                                ## at full speed and above then it sets this value to 1.
  bU1DevExitLat*: uint8       ## U1 Device Exit Latency.
  bU2DevExitLat*: uint16      ## U2 Device Exit Latency."><wbr />libusb_<wbr />ss_<wbr />usb_<wbr />device_<wbr />capability_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_container_id_descriptor"
    title="libusb_container_id_descriptor = object 
  bLength*: uint8             ## Size of this descriptor (in bytes).
  bDescriptorType*: uint8     ## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).
  bDevCapabilityType*: uint8  ## Capability type (LIBUSB_BT_CONTAINER_ID).
  bReserved*: uint8           ## Reserved for future use.
  ContainerID*: array[16, uint8] ## 128 bit UUID."><wbr />libusb_<wbr />container_<wbr />id_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_control_setup"
    title="libusb_control_setup = object 
  bmRequestType*: uint8 ## Request type. Bits 0:4 determine recipient, see
                        ## `libusb_request_recipient`. Bits 5:6 determine type, see
                        ## `libusb_request_type`. Bit 7 determines data transfer direction, see
                        ## `libusb_endpoint_direction`.
  bRequest*: uint8 ## Request. If the type bits of `bmRequestType` are equal
                   ## to `LIBUSB_REQUEST_TYPE_STANDARD` then this field refers to
                   ## `libusb_standard_request`. For other cases, use of this field is
                   ## application-specific.
  wValue*: uint16             ## Value. Varies according to request.
  wIndex*: uint16 ## Index. Varies according to request, typically used to
                  ## pass an index or offset
  wLength*: uint16            ## Number of bytes to transfer."><wbr />libusb_<wbr />control_<wbr />setup</a></li>
  <li><a class="reference" href="#libusb_version"
    title="libusb_version = object 
  major*: uint16              ## Library major version.
  minor*: uint16              ## Library minor version.
  micro*: uint16              ## Library micro version.
  nano*: uint16               ## Library nano version.
  rc*: cstring                ## Library release candidate suffix string, e.g. &quot;-rc4&quot;.
  describe*: cstring          ## For ABI compatibility only."><wbr />libusb_<wbr />version</a></li>
  <li><a class="reference" href="#libusb_context"
    title="libusb_context = object"><wbr />libusb_<wbr />context</a></li>
  <li><a class="reference" href="#libusb_device"
    title="libusb_device = object"><wbr />libusb_<wbr />device</a></li>
  <li><a class="reference" href="#libusb_device_array"
    title="libusb_device_array = array[10000, ptr libusb_device]"><wbr />libusb_<wbr />device_<wbr />array</a></li>
  <li><a class="reference" href="#libusb_device_handle"
    title="libusb_device_handle = object"><wbr />libusb_<wbr />device_<wbr />handle</a></li>
  <li><a class="reference" href="#libusb_speed"
    title="libusb_speed = enum 
  LIBUSB_SPEED_UNKNOWN = 0,   ## The OS doesn&#x27;t report or know the device speed.
  LIBUSB_SPEED_LOW = 1,       ## The device is operating at low speed (1.5MBit&#x2F;s).
  LIBUSB_SPEED_FULL = 2,      ## The device is operating at full speed (12MBit&#x2F;s).
  LIBUSB_SPEED_HIGH = 3,      ## The device is operating at high speed (480MBit&#x2F;s).
  LIBUSB_SPEED_SUPER = 4      ##The device is operating at super speed (5000MBit&#x2F;s)."><wbr />libusb_<wbr />speed</a></li>
  <li><a class="reference" href="#libusb_supported_speed"
    title="libusb_supported_speed = enum 
  LIBUSB_LOW_SPEED_OPERATION = 1, ## Low speed operation supported (1.5MBit&#x2F;s).
  LIBUSB_FULL_SPEED_OPERATION = 2, ## Full speed operation supported (12MBit&#x2F;s).
  LIBUSB_HIGH_SPEED_OPERATION = 4, ## High speed operation supported (480MBit&#x2F;s).
  LIBUSB_SUPER_SPEED_OPERATION = 8 ## Superspeed operation supported (5000MBit&#x2F;s)."><wbr />libusb_<wbr />supported_<wbr />speed</a></li>
  <li><a class="reference" href="#libusb_usb_2_0_extension_attributes"
    title="libusb_usb_2_0_extension_attributes = enum 
  LIBUSB_BM_LPM_SUPPORT = 2   ## Supports Link Power Management (LPM)."><wbr />libusb_<wbr />usb_<wbr />2_<wbr />0_<wbr />extension_<wbr />attributes</a></li>
  <li><a class="reference" href="#libusb_ss_usb_device_capability_attributes"
    title="libusb_ss_usb_device_capability_attributes = enum 
  LIBUSB_BM_LTM_SUPPORT = 2   ## Supports Latency Tolerance Messages (LTM)."><wbr />libusb_<wbr />ss_<wbr />usb_<wbr />device_<wbr />capability_<wbr />attributes</a></li>
  <li><a class="reference" href="#libusb_bos_type"
    title="libusb_bos_type = enum 
  LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY = 1, ## Wireless USB device capability.
  LIBUSB_BT_USB_2_0_EXTENSION = 2, ## USB 2.0 extensions.
  LIBUSB_BT_SS_USB_DEVICE_CAPABILITY = 3, ## SuperSpeed USB device capability.
  LIBUSB_BT_CONTAINER_ID = 4  ## Container ID type."><wbr />libusb_<wbr />bos_<wbr />type</a></li>
  <li><a class="reference" href="#libusb_error"
    title="libusb_error = enum 
  LIBUSB_ERROR_OTHER = - 99,  ## Other error.
  LIBUSB_ERROR_NOT_SUPPORTED = - 12, ## Operation not supported or unimplemented on this platform.
  LIBUSB_ERROR_NO_MEM = - 11, ## Insufficient memory.
  LIBUSB_ERROR_INTERRUPTED = - 10, ## System call interrupted (perhaps due to signal) 
  LIBUSB_ERROR_PIPE = - 9,    ## Pipe error.
  LIBUSB_ERROR_OVERFLOW = - 8, ## Overflow.
  LIBUSB_ERROR_TIMEOUT = - 7, ## Operation timed out.
  LIBUSB_ERROR_BUSY = - 6,    ## Resource busy.
  LIBUSB_ERROR_NOT_FOUND = - 5, ## Entity not found.
  LIBUSB_ERROR_NO_DEVICE = - 4, ## No such device (it may have been disconnected).
  LIBUSB_ERROR_ACCESS = - 3,  ## Access denied (insufficient permissions)
  LIBUSB_ERROR_INVALID_PARAM = - 2, ## Invalid parameter.
  LIBUSB_ERROR_IO = - 1,      ## Input&#x2F;output error.
  LIBUSB_SUCCESS = 0          ## Success (no error)."><wbr />libusb_<wbr />error</a></li>
  <li><a class="reference" href="#libusb_transfer_status"
    title="libusb_transfer_status = enum 
  LIBUSB_TRANSFER_COMPLETED, ## Transfer completed without error.
                             ## Note that this does not indicate that the entire amount of requested
                             ## data was transferred.
  LIBUSB_TRANSFER_ERROR,      ## Transfer failed.
  LIBUSB_TRANSFER_TIMED_OUT,  ## Transfer timed out.
  LIBUSB_TRANSFER_CANCELLED,  ## Transfer was cancelled.
  LIBUSB_TRANSFER_STALL, ## For bulk&#x2F;interrupt endpoints: halt condition
                         ## detected (endpoint stalled). For control endpoints: control request
                         ## not supported.
  LIBUSB_TRANSFER_NO_DEVICE,  ## Device was disconnected.
  LIBUSB_TRANSFER_OVERFLOW    ## Device sent more data than requested."><wbr />libusb_<wbr />transfer_<wbr />status</a></li>
  <li><a class="reference" href="#libusb_transfer_flags"
    title="libusb_transfer_flags = enum 
  LIBUSB_TRANSFER_SHORT_NOT_OK = 1 shl 0, ## Report short frames as errors.
  LIBUSB_TRANSFER_FREE_BUFFER = 1 shl 1, ## Automatically `free()` transfer
                                         ## buffer during `libusb_free_transfer()`
  LIBUSB_TRANSFER_FREE_TRANSFER = 1 shl 2, ## Automatically call
                                           ## `libusb_free_transfer()` after callback returns. If this flag is set,
                                           ## it is illegal to call `libusb_free_transfer()` from your transfer
                                           ## callback, as this will result in a double-free when this flag is acted
                                           ## upon.
  LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 shl 3 ## Terminate transfers that are \
                                            ## a multiple of the endpoint&#x27;s wMaxPacketSize with an extra zero length
                                            ## packet. This is useful when a device protocol mandates that each
                                            ## logical request is terminated by an incomplete packet (i.e. the logical
                                            ## requests are not separated by other means).
                                            ##
                                            ## This flag only affects host-to-device transfers to bulk and interrupt
                                            ## endpoints. In other situations, it is ignored.
                                            ##
                                            ## This flag only affects transfers with a length that is a multiple of 
                                            ## the endpoint&#x27;s wMaxPacketSize. On transfers of other lengths, this flag
                                            ## has no effect. Therefore, if you are working with a device that needs a
                                            ## ZLP whenever the end of the logical request falls on a packet boundary,
                                            ## then it is sensible to set this flag on every transfer (you do not have
                                            ## to worry about only setting it on transfers that end on the boundary).
                                            ##
                                            ## This flag is currently only supported on Linux. On other systems,
                                            ## `libusb_submit_transfer()` will return `LIBUSB_ERROR_NOT_SUPPORTED`
                                            ## for every transfer where this flag is set."><wbr />libusb_<wbr />transfer_<wbr />flags</a></li>
  <li><a class="reference" href="#libusb_iso_packet_descriptor"
    title="libusb_iso_packet_descriptor = object 
  length*: cuint              ## Length of data to request in this packet.
  actual_length*: cuint       ## Amount of data that was actually transferred.
  status*: libusb_transfer_status ## Status code for this packet."><wbr />libusb_<wbr />iso_<wbr />packet_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_transfer_cb_fn"
    title="libusb_transfer_cb_fn = proc (transfer: ptr libusb_transfer)"><wbr />libusb_<wbr />transfer_<wbr />cb_<wbr />fn</a></li>
  <li><a class="reference" href="#libusb_transfer"
    title="libusb_transfer = object 
  dev_handle*: ptr libusb_device_handle ## Handle of the device that this
                                        ## transfer will be submitted to.
  flags*: uint8               ## A bitwise OR combination of `libusb_transfer_flags`.
  endpoint*: cuchar           ## Address of the endpoint where this transfer will be sent.
  `type`*: libusb_transfer_type ## Type of the endpoint from `libusb_transfer_type`.
  timeout*: cuint ## Timeout for this transfer in millseconds. A value of 0
                  ## indicates no timeout.
  status*: libusb_transfer_status ## The status of the transfer. Read-only,
                                  ## and only for use within transfer callback function.
                                  ##
                                  ## If this is an isochronous transfer, this field may read COMPLETED even
                                  ## if there were errors in the frames. Use the
                                  ## `libusb_iso_packet_descriptor.status` field in each packet to determine
                                  ## if errors occurred.
  length*: cint               ## Length of the data buffer.
  actual_length*: cint ## Actual length of data that was transferred.
                       ## Read-only, and only for use within transfer callback function.
                       ## Not valid for isochronous endpoint transfers.
  callback*: libusb_transfer_cb_fn ## Callback function. This will be invoked
                                   ## when the transfer completes, fails, or is cancelled.
                                   ## TODO: convert this to Nim
  user_data*: pointer         ## User context data to pass to the callback function.
  buffer*: cstring            ## Data buffer.
  num_iso_packets*: cint ## Number of isochronous packets. Only used for I&#x2F;O
                         ## with isochronous endpoints.
  iso_packet_desc*: libusb_iso_packet_descriptor_array ## Isochronous packet
                                                       ## descriptors, for isochronous transfers only."><wbr />libusb_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_capability"
    title="libusb_capability = enum 
  LIBUSB_CAP_HAS_CAPABILITY = 0x00000000, ## The libusb_has_capability() API
                                          ## is available.
  LIBUSB_CAP_HAS_HOTPLUG = 0x00000001, ## Hotplug support is available on this
                                       ## platform.
  LIBUSB_CAP_HAS_HID_ACCESS = 0x00000100, ## The library can access HID
                                          ## devices without requiring user intervention. Note that before being
                                          ## able to actually access an HID device, you may still have to call
                                          ## additional libusb functions such as `libusb_detach_kernel_driver()`.
  LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x00000101 ## The library
                                                        ## supports detaching of the default USB driver, using
                                                        ## `libusb_detach_kernel_driver()`, if one is set by the OS kernel."><wbr />libusb_<wbr />capability</a></li>
  <li><a class="reference" href="#libusb_log_level"
    title="libusb_log_level = enum 
  LIBUSB_LOG_LEVEL_NONE = 0,  ## No messages ever printed by the library (default)
  LIBUSB_LOG_LEVEL_ERROR,     ## Error messages are printed to stderr
  LIBUSB_LOG_LEVEL_WARNING,   ## Warning and error messages are printed to stderr
  LIBUSB_LOG_LEVEL_INFO,      ## Informational messages are printed to stdout,
                              ## warning and error messages are printed to stderr
  LIBUSB_LOG_LEVEL_DEBUG      ## Debug and informational messages are printed to
                              ## stdout, warnings and errors to stderr"><wbr />libusb_<wbr />log_<wbr />level</a></li>
  <li><a class="reference" href="#libusb_pollfd"
    title="libusb_pollfd = object 
  fd*: cint                   ## Numeric file descriptor 
  events*: cshort ## Event flags to poll for from &lt;poll.h&gt;. POLLIN indicates
                  ## that you should monitor this file descriptor for becoming ready to read
                  ## from, and POLLOUT indicates that you should monitor this file descriptor
                  ## for nonblocking write readiness."><wbr />libusb_<wbr />pollfd</a></li>
  <li><a class="reference" href="#libusb_pollfd_added_cb"
    title="libusb_pollfd_added_cb = proc (fd: cint; events: cshort; user_data: pointer)"><wbr />libusb_<wbr />pollfd_<wbr />added_<wbr />cb</a></li>
  <li><a class="reference" href="#libusb_pollfd_removed_cb"
    title="libusb_pollfd_removed_cb = proc (fd: cint; user_data: pointer)"><wbr />libusb_<wbr />pollfd_<wbr />removed_<wbr />cb</a></li>
  <li><a class="reference" href="#libusb_hotplug_callback_handle"
    title="libusb_hotplug_callback_handle = cint"><wbr />libusb_<wbr />hotplug_<wbr />callback_<wbr />handle</a></li>
  <li><a class="reference" href="#libusb_hotplug_flag"
    title="libusb_hotplug_flag = enum 
  LIBUSB_HOTPLUG_NO_FLAGS = 0, ## Default value when not using any flags.
  LIBUSB_HOTPLUG_ENUMERATE = 1 shl 0 ## Arm the callback and fire it for all
                                     ## matching currently attached devices."><wbr />libusb_<wbr />hotplug_<wbr />flag</a></li>
  <li><a class="reference" href="#libusb_hotplug_event"
    title="libusb_hotplug_event = enum 
  LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED = 0x00000001, ## A device has been
                                                    ## plugged in and is ready to use.
  LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT = 0x00000002 ## A device has left and is no
                                                ## longer available. It is the user&#x27;s responsibility to call `libusb_close`
                                                ## on any handle associated with a disconnected device. It is safe to call
                                                ## `libusb_get_device_descriptor` on a device that has left."><wbr />libusb_<wbr />hotplug_<wbr />event</a></li>
  <li><a class="reference" href="#libusb_hotplug_callback_fn"
    title="libusb_hotplug_callback_fn = proc (ctx: ptr libusb_context; 
                                   device: ptr libusb_device; 
                                   event: libusb_hotplug_event; 
                                   user_data: pointer): cint"><wbr />libusb_<wbr />hotplug_<wbr />callback_<wbr />fn</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#LIBUSB_API_VERSION"
    title="LIBUSB_API_VERSION = 0x01000103"><wbr />LIBUSB_<wbr />API_<wbr />VERSION</a></li>
  <li><a class="reference" href="#LIBUSB_DT_DEVICE_SIZE"
    title="LIBUSB_DT_DEVICE_SIZE = 18"><wbr />LIBUSB_<wbr />DT_<wbr />DEVICE_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_CONFIG_SIZE"
    title="LIBUSB_DT_CONFIG_SIZE = 9"><wbr />LIBUSB_<wbr />DT_<wbr />CONFIG_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_INTERFACE_SIZE"
    title="LIBUSB_DT_INTERFACE_SIZE = 9"><wbr />LIBUSB_<wbr />DT_<wbr />INTERFACE_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_ENDPOINT_SIZE"
    title="LIBUSB_DT_ENDPOINT_SIZE = 7"><wbr />LIBUSB_<wbr />DT_<wbr />ENDPOINT_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_ENDPOINT_AUDIO_SIZE"
    title="LIBUSB_DT_ENDPOINT_AUDIO_SIZE = 9"><wbr />LIBUSB_<wbr />DT_<wbr />ENDPOINT_<wbr />AUDIO_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_HUB_NONVAR_SIZE"
    title="LIBUSB_DT_HUB_NONVAR_SIZE = 7"><wbr />LIBUSB_<wbr />DT_<wbr />HUB_<wbr />NONVAR_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE"
    title="LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE = 6"><wbr />LIBUSB_<wbr />DT_<wbr />SS_<wbr />ENDPOINT_<wbr />COMPANION_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_BOS_SIZE"
    title="LIBUSB_DT_BOS_SIZE = 5"><wbr />LIBUSB_<wbr />DT_<wbr />BOS_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_DEVICE_CAPABILITY_SIZE"
    title="LIBUSB_DT_DEVICE_CAPABILITY_SIZE = 3"><wbr />LIBUSB_<wbr />DT_<wbr />DEVICE_<wbr />CAPABILITY_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_BT_USB_2_0_EXTENSION_SIZE"
    title="LIBUSB_BT_USB_2_0_EXTENSION_SIZE = 7"><wbr />LIBUSB_<wbr />BT_<wbr />USB_<wbr />2_<wbr />0_<wbr />EXTENSION_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE"
    title="LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE = 10"><wbr />LIBUSB_<wbr />BT_<wbr />SS_<wbr />USB_<wbr />DEVICE_<wbr />CAPABILITY_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_BT_CONTAINER_ID_SIZE"
    title="LIBUSB_BT_CONTAINER_ID_SIZE = 20"><wbr />LIBUSB_<wbr />BT_<wbr />CONTAINER_<wbr />ID_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_DT_BOS_MAX_SIZE"
    title="LIBUSB_DT_BOS_MAX_SIZE = 42"><wbr />LIBUSB_<wbr />DT_<wbr />BOS_<wbr />MAX_<wbr />SIZE</a></li>
  <li><a class="reference" href="#LIBUSB_ENDPOINT_ADDRESS_MASK"
    title="LIBUSB_ENDPOINT_ADDRESS_MASK = 0x0000000F"><wbr />LIBUSB_<wbr />ENDPOINT_<wbr />ADDRESS_<wbr />MASK</a></li>
  <li><a class="reference" href="#LIBUSB_ENDPOINT_DIR_MASK"
    title="LIBUSB_ENDPOINT_DIR_MASK = 0x00000080"><wbr />LIBUSB_<wbr />ENDPOINT_<wbr />DIR_<wbr />MASK</a></li>
  <li><a class="reference" href="#LIBUSB_TRANSFER_TYPE_MASK"
    title="LIBUSB_TRANSFER_TYPE_MASK = 0x00000003"><wbr />LIBUSB_<wbr />TRANSFER_<wbr />TYPE_<wbr />MASK</a></li>
  <li><a class="reference" href="#LIBUSB_ISO_SYNC_TYPE_MASK"
    title="LIBUSB_ISO_SYNC_TYPE_MASK = 0x0000000C"><wbr />LIBUSB_<wbr />ISO_<wbr />SYNC_<wbr />TYPE_<wbr />MASK</a></li>
  <li><a class="reference" href="#LIBUSB_ISO_USAGE_TYPE_MASK"
    title="LIBUSB_ISO_USAGE_TYPE_MASK = 0x00000030"><wbr />LIBUSB_<wbr />ISO_<wbr />USAGE_<wbr />TYPE_<wbr />MASK</a></li>
  <li><a class="reference" href="#LIBUSB_ERROR_COUNT"
    title="LIBUSB_ERROR_COUNT = 14"><wbr />LIBUSB_<wbr />ERROR_<wbr />COUNT</a></li>
  <li><a class="reference" href="#LIBUSB_HOTPLUG_MATCH_ANY"
    title="LIBUSB_HOTPLUG_MATCH_ANY = -1"><wbr />LIBUSB_<wbr />HOTPLUG_<wbr />MATCH_<wbr />ANY</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libusb_cpu_to_le16,uint16"
    title="libusb_cpu_to_le16(x: uint16): uint16"><wbr />libusb_<wbr />cpu_<wbr />to_<wbr />le16</a></li>
  <li><a class="reference" href="#libusb_init,ptr.ptr.libusb_context"
    title="libusb_init(ctx: ptr ptr libusb_context): cint"><wbr />libusb_<wbr />init</a></li>
  <li><a class="reference" href="#libusb_exit,ptr.libusb_context"
    title="libusb_exit(ctx: ptr libusb_context)"><wbr />libusb_<wbr />exit</a></li>
  <li><a class="reference" href="#libusb_set_debug,ptr.libusb_context,cint"
    title="libusb_set_debug(ctx: ptr libusb_context; level: cint)"><wbr />libusb_<wbr />set_<wbr />debug</a></li>
  <li><a class="reference" href="#libusb_get_version,"
    title="libusb_get_version(): ptr libusb_version"><wbr />libusb_<wbr />get_<wbr />version</a></li>
  <li><a class="reference" href="#libusb_has_capability,uint32"
    title="libusb_has_capability(capability: uint32): cint"><wbr />libusb_<wbr />has_<wbr />capability</a></li>
  <li><a class="reference" href="#libusb_error_name,cint"
    title="libusb_error_name(errcode: cint): cstring"><wbr />libusb_<wbr />error_<wbr />name</a></li>
  <li><a class="reference" href="#libusb_setlocale,cstring"
    title="libusb_setlocale(locale: cstring): cint"><wbr />libusb_<wbr />setlocale</a></li>
  <li><a class="reference" href="#libusb_strerror,libusb_error"
    title="libusb_strerror(errcode: libusb_error): cstring"><wbr />libusb_<wbr />strerror</a></li>
  <li><a class="reference" href="#libusb_get_device_list,ptr.libusb_context,ptr.ptr.libusb_device_array"
    title="libusb_get_device_list(ctx: ptr libusb_context; 
                       list: ptr ptr libusb_device_array): csize"><wbr />libusb_<wbr />get_<wbr />device_<wbr />list</a></li>
  <li><a class="reference" href="#libusb_free_device_list,ptr.libusb_device_array,cint"
    title="libusb_free_device_list(list: ptr libusb_device_array; unref_devices: cint)"><wbr />libusb_<wbr />free_<wbr />device_<wbr />list</a></li>
  <li><a class="reference" href="#libusb_ref_device,ptr.libusb_device"
    title="libusb_ref_device(dev: ptr libusb_device): ptr libusb_device"><wbr />libusb_<wbr />ref_<wbr />device</a></li>
  <li><a class="reference" href="#libusb_unref_device,ptr.libusb_device"
    title="libusb_unref_device(dev: ptr libusb_device)"><wbr />libusb_<wbr />unref_<wbr />device</a></li>
  <li><a class="reference" href="#libusb_get_configuration,ptr.libusb_device_handle,ptr.cint"
    title="libusb_get_configuration(dev: ptr libusb_device_handle; config: ptr cint): cint"><wbr />libusb_<wbr />get_<wbr />configuration</a></li>
  <li><a class="reference" href="#libusb_get_device_descriptor,ptr.libusb_device,ptr.libusb_device_descriptor"
    title="libusb_get_device_descriptor(dev: ptr libusb_device; 
                             desc: ptr libusb_device_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />device_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_active_config_descriptor,ptr.libusb_device,ptr.ptr.libusb_config_descriptor"
    title="libusb_get_active_config_descriptor(dev: ptr libusb_device; 
                                    config: ptr ptr libusb_config_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />active_<wbr />config_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_config_descriptor,ptr.libusb_device,uint8,ptr.ptr.libusb_config_descriptor"
    title="libusb_get_config_descriptor(dev: ptr libusb_device; config_index: uint8; 
                             config: ptr ptr libusb_config_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />config_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_config_descriptor_by_value,ptr.libusb_device,uint8,ptr.ptr.libusb_config_descriptor"
    title="libusb_get_config_descriptor_by_value(dev: ptr libusb_device; 
                                      bConfigurationValue: uint8; 
                                      config: ptr ptr libusb_config_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />config_<wbr />descriptor_<wbr />by_<wbr />value</a></li>
  <li><a class="reference" href="#libusb_free_config_descriptor,ptr.libusb_config_descriptor"
    title="libusb_free_config_descriptor(config: ptr libusb_config_descriptor)"><wbr />libusb_<wbr />free_<wbr />config_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_ss_endpoint_companion_descriptor,ptr.libusb_context,ptr.libusb_endpoint_descriptor,ptr.ptr.libusb_ss_endpoint_companion_descriptor"
    title="libusb_get_ss_endpoint_companion_descriptor(ctx: ptr libusb_context; 
    endpoint: ptr libusb_endpoint_descriptor; 
    ep_comp: ptr ptr libusb_ss_endpoint_companion_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />ss_<wbr />endpoint_<wbr />companion_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_free_ss_endpoint_companion_descriptor,ptr.libusb_ss_endpoint_companion_descriptor"
    title="libusb_free_ss_endpoint_companion_descriptor(
    ep_comp: ptr libusb_ss_endpoint_companion_descriptor)"><wbr />libusb_<wbr />free_<wbr />ss_<wbr />endpoint_<wbr />companion_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_bos_descriptor,ptr.libusb_device_handle,ptr.ptr.libusb_bos_descriptor"
    title="libusb_get_bos_descriptor(handle: ptr libusb_device_handle; 
                          bos: ptr ptr libusb_bos_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />bos_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_free_bos_descriptor,ptr.libusb_bos_descriptor"
    title="libusb_free_bos_descriptor(bos: ptr libusb_bos_descriptor)"><wbr />libusb_<wbr />free_<wbr />bos_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_usb_2_0_extension_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_usb_2_0_extension_descriptor"
    title="libusb_get_usb_2_0_extension_descriptor(ctx: ptr libusb_context; dev_cap: ptr libusb_bos_dev_capability_descriptor; 
    usb_2_0_extension: ptr ptr libusb_usb_2_0_extension_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />usb_<wbr />2_<wbr />0_<wbr />extension_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_free_usb_2_0_extension_descriptor,ptr.libusb_usb_2_0_extension_descriptor"
    title="libusb_free_usb_2_0_extension_descriptor(
    usb_2_0_extension: ptr libusb_usb_2_0_extension_descriptor)"><wbr />libusb_<wbr />free_<wbr />usb_<wbr />2_<wbr />0_<wbr />extension_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_ss_usb_device_capability_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_ss_usb_device_capability_descriptor"
    title="libusb_get_ss_usb_device_capability_descriptor(ctx: ptr libusb_context; 
    dev_cap: ptr libusb_bos_dev_capability_descriptor; 
    ss_usb_device_cap: ptr ptr libusb_ss_usb_device_capability_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />ss_<wbr />usb_<wbr />device_<wbr />capability_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_free_ss_usb_device_capability_descriptor,ptr.libusb_ss_usb_device_capability_descriptor"
    title="libusb_free_ss_usb_device_capability_descriptor(
    ss_usb_device_cap: ptr libusb_ss_usb_device_capability_descriptor)"><wbr />libusb_<wbr />free_<wbr />ss_<wbr />usb_<wbr />device_<wbr />capability_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_container_id_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_container_id_descriptor"
    title="libusb_get_container_id_descriptor(ctx: ptr libusb_context; dev_cap: ptr libusb_bos_dev_capability_descriptor; 
    container_id: ptr ptr libusb_container_id_descriptor): cint"><wbr />libusb_<wbr />get_<wbr />container_<wbr />id_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_free_container_id_descriptor,ptr.libusb_container_id_descriptor"
    title="libusb_free_container_id_descriptor(container_id: ptr libusb_container_id_descriptor)"><wbr />libusb_<wbr />free_<wbr />container_<wbr />id_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_bus_number,ptr.libusb_device"
    title="libusb_get_bus_number(dev: ptr libusb_device): uint8"><wbr />libusb_<wbr />get_<wbr />bus_<wbr />number</a></li>
  <li><a class="reference" href="#libusb_get_port_number,ptr.libusb_device"
    title="libusb_get_port_number(dev: ptr libusb_device): uint8"><wbr />libusb_<wbr />get_<wbr />port_<wbr />number</a></li>
  <li><a class="reference" href="#libusb_get_port_numbers,ptr.libusb_device,ptr.uint8,cint"
    title="libusb_get_port_numbers(dev: ptr libusb_device; port_numbers: ptr uint8; 
                        port_numbers_len: cint): cint"><wbr />libusb_<wbr />get_<wbr />port_<wbr />numbers</a></li>
  <li><a class="reference" href="#libusb_get_parent,ptr.libusb_device"
    title="libusb_get_parent(dev: ptr libusb_device): ptr libusb_device"><wbr />libusb_<wbr />get_<wbr />parent</a></li>
  <li><a class="reference" href="#libusb_get_device_address,ptr.libusb_device"
    title="libusb_get_device_address(dev: ptr libusb_device): uint8"><wbr />libusb_<wbr />get_<wbr />device_<wbr />address</a></li>
  <li><a class="reference" href="#libusb_get_device_speed,ptr.libusb_device"
    title="libusb_get_device_speed(dev: ptr libusb_device): cint"><wbr />libusb_<wbr />get_<wbr />device_<wbr />speed</a></li>
  <li><a class="reference" href="#libusb_get_max_packet_size,ptr.libusb_device,cuchar"
    title="libusb_get_max_packet_size(dev: ptr libusb_device; endpoint: cuchar): cint"><wbr />libusb_<wbr />get_<wbr />max_<wbr />packet_<wbr />size</a></li>
  <li><a class="reference" href="#libusb_get_max_iso_packet_size,ptr.libusb_device,cuchar"
    title="libusb_get_max_iso_packet_size(dev: ptr libusb_device; endpoint: cuchar): cint"><wbr />libusb_<wbr />get_<wbr />max_<wbr />iso_<wbr />packet_<wbr />size</a></li>
  <li><a class="reference" href="#libusb_open,ptr.libusb_device,ptr.ptr.libusb_device_handle"
    title="libusb_open(dev: ptr libusb_device; handle: ptr ptr libusb_device_handle): cint"><wbr />libusb_<wbr />open</a></li>
  <li><a class="reference" href="#libusb_close,ptr.libusb_device_handle"
    title="libusb_close(dev_handle: ptr libusb_device_handle)"><wbr />libusb_<wbr />close</a></li>
  <li><a class="reference" href="#libusb_get_device,ptr.libusb_device_handle"
    title="libusb_get_device(dev_handle: ptr libusb_device_handle): ptr libusb_device"><wbr />libusb_<wbr />get_<wbr />device</a></li>
  <li><a class="reference" href="#libusb_set_configuration,ptr.libusb_device_handle,cint"
    title="libusb_set_configuration(dev: ptr libusb_device_handle; configuration: cint): cint"><wbr />libusb_<wbr />set_<wbr />configuration</a></li>
  <li><a class="reference" href="#libusb_claim_interface,ptr.libusb_device_handle,cint"
    title="libusb_claim_interface(dev: ptr libusb_device_handle; interface_number: cint): cint"><wbr />libusb_<wbr />claim_<wbr />interface</a></li>
  <li><a class="reference" href="#libusb_release_interface,ptr.libusb_device_handle,cint"
    title="libusb_release_interface(dev: ptr libusb_device_handle; interface_number: cint): cint"><wbr />libusb_<wbr />release_<wbr />interface</a></li>
  <li><a class="reference" href="#libusb_open_device_with_vid_pid,ptr.libusb_context,uint16,uint16"
    title="libusb_open_device_with_vid_pid(ctx: ptr libusb_context; vendor_id: uint16; 
                                product_id: uint16): ptr libusb_device_handle"><wbr />libusb_<wbr />open_<wbr />device_<wbr />with_<wbr />vid_<wbr />pid</a></li>
  <li><a class="reference" href="#libusb_set_interface_alt_setting,ptr.libusb_device_handle,cint,cint"
    title="libusb_set_interface_alt_setting(dev: ptr libusb_device_handle; 
                                 interface_number: cint; alternate_setting: cint): cint"><wbr />libusb_<wbr />set_<wbr />interface_<wbr />alt_<wbr />setting</a></li>
  <li><a class="reference" href="#libusb_clear_halt,ptr.libusb_device_handle,cuchar"
    title="libusb_clear_halt(dev: ptr libusb_device_handle; endpoint: cuchar): cint"><wbr />libusb_<wbr />clear_<wbr />halt</a></li>
  <li><a class="reference" href="#libusb_reset_device,ptr.libusb_device_handle"
    title="libusb_reset_device(dev: ptr libusb_device_handle): cint"><wbr />libusb_<wbr />reset_<wbr />device</a></li>
  <li><a class="reference" href="#libusb_alloc_streams,ptr.libusb_device_handle,uint32,ptr.cuchar,cint"
    title="libusb_alloc_streams(dev: ptr libusb_device_handle; num_streams: uint32; 
                     endpoints: ptr cuchar; num_endpoints: cint): cint"><wbr />libusb_<wbr />alloc_<wbr />streams</a></li>
  <li><a class="reference" href="#libusb_free_streams,ptr.libusb_device_handle,ptr.cuchar,cint"
    title="libusb_free_streams(dev: ptr libusb_device_handle; endpoints: ptr cuchar; 
                    num_endpoints: cint): cint"><wbr />libusb_<wbr />free_<wbr />streams</a></li>
  <li><a class="reference" href="#libusb_kernel_driver_active,ptr.libusb_device_handle,cint"
    title="libusb_kernel_driver_active(dev: ptr libusb_device_handle; 
                            interface_number: cint): cint"><wbr />libusb_<wbr />kernel_<wbr />driver_<wbr />active</a></li>
  <li><a class="reference" href="#libusb_detach_kernel_driver,ptr.libusb_device_handle,cint"
    title="libusb_detach_kernel_driver(dev: ptr libusb_device_handle; 
                            interface_number: cint): cint"><wbr />libusb_<wbr />detach_<wbr />kernel_<wbr />driver</a></li>
  <li><a class="reference" href="#libusb_attach_kernel_driver,ptr.libusb_device_handle,cint"
    title="libusb_attach_kernel_driver(dev: ptr libusb_device_handle; 
                            interface_number: cint): cint"><wbr />libusb_<wbr />attach_<wbr />kernel_<wbr />driver</a></li>
  <li><a class="reference" href="#libusb_set_auto_detach_kernel_driver,ptr.libusb_device_handle,cint"
    title="libusb_set_auto_detach_kernel_driver(dev: ptr libusb_device_handle; enable: cint): cint"><wbr />libusb_<wbr />set_<wbr />auto_<wbr />detach_<wbr />kernel_<wbr />driver</a></li>
  <li><a class="reference" href="#libusb_control_transfer_get_data,ptr.libusb_transfer"
    title="libusb_control_transfer_get_data(transfer: ptr libusb_transfer): ptr cuchar"><wbr />libusb_<wbr />control_<wbr />transfer_<wbr />get_<wbr />data</a></li>
  <li><a class="reference" href="#libusb_control_transfer_get_setup,ptr.libusb_transfer"
    title="libusb_control_transfer_get_setup(transfer: ptr libusb_transfer): ptr libusb_control_setup"><wbr />libusb_<wbr />control_<wbr />transfer_<wbr />get_<wbr />setup</a></li>
  <li><a class="reference" href="#libusb_fill_control_setup,ptr.cuchar,uint8,uint8,uint16,uint16,uint16"
    title="libusb_fill_control_setup(buffer: ptr cuchar; bmRequestType: uint8; 
                          bRequest: uint8; wValue: uint16; wIndex: uint16; 
                          wLength: uint16)"><wbr />libusb_<wbr />fill_<wbr />control_<wbr />setup</a></li>
  <li><a class="reference" href="#libusb_alloc_transfer,cint"
    title="libusb_alloc_transfer(iso_packets: cint): ptr libusb_transfer"><wbr />libusb_<wbr />alloc_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_submit_transfer,ptr.libusb_transfer"
    title="libusb_submit_transfer(transfer: ptr libusb_transfer): cint"><wbr />libusb_<wbr />submit_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_cancel_transfer,ptr.libusb_transfer"
    title="libusb_cancel_transfer(transfer: ptr libusb_transfer): cint"><wbr />libusb_<wbr />cancel_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_free_transfer,ptr.libusb_transfer"
    title="libusb_free_transfer(transfer: ptr libusb_transfer)"><wbr />libusb_<wbr />free_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_transfer_set_stream_id,ptr.libusb_transfer,uint32"
    title="libusb_transfer_set_stream_id(transfer: ptr libusb_transfer; stream_id: uint32)"><wbr />libusb_<wbr />transfer_<wbr />set_<wbr />stream_<wbr />id</a></li>
  <li><a class="reference" href="#libusb_transfer_get_stream_id,ptr.libusb_transfer"
    title="libusb_transfer_get_stream_id(transfer: ptr libusb_transfer): uint32"><wbr />libusb_<wbr />transfer_<wbr />get_<wbr />stream_<wbr />id</a></li>
  <li><a class="reference" href="#libusb_fill_control_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,ptr.cuchar,libusb_transfer_cb_fn,pointer,cuint"
    title="libusb_fill_control_transfer(transfer: ptr libusb_transfer; 
                             dev_handle: ptr libusb_device_handle; 
                             buffer: ptr cuchar; 
                             callback: libusb_transfer_cb_fn; 
                             user_data: pointer; timeout: cuint)"><wbr />libusb_<wbr />fill_<wbr />control_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_fill_bulk_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"
    title="libusb_fill_bulk_transfer(transfer: ptr libusb_transfer; 
                          dev_handle: ptr libusb_device_handle; 
                          endpoint: cuchar; buffer: ptr cuchar; length: cint; 
                          callback: libusb_transfer_cb_fn; user_data: pointer; 
                          timeout: cuint)"><wbr />libusb_<wbr />fill_<wbr />bulk_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_fill_bulk_stream_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,uint32,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"
    title="libusb_fill_bulk_stream_transfer(transfer: ptr libusb_transfer; 
                                 dev_handle: ptr libusb_device_handle; 
                                 endpoint: cuchar; stream_id: uint32; 
                                 buffer: ptr cuchar; length: cint; 
                                 callback: libusb_transfer_cb_fn; 
                                 user_data: pointer; timeout: cuint)"><wbr />libusb_<wbr />fill_<wbr />bulk_<wbr />stream_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_fill_interrupt_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"
    title="libusb_fill_interrupt_transfer(transfer: ptr libusb_transfer; 
                               dev_handle: ptr libusb_device_handle; 
                               endpoint: cuchar; buffer: ptr cuchar; 
                               length: cint; callback: libusb_transfer_cb_fn; 
                               user_data: pointer; timeout: cuint)"><wbr />libusb_<wbr />fill_<wbr />interrupt_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_fill_iso_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,cint,libusb_transfer_cb_fn,pointer,cuint"
    title="libusb_fill_iso_transfer(transfer: ptr libusb_transfer; 
                         dev_handle: ptr libusb_device_handle; endpoint: cuchar; 
                         buffer: ptr cuchar; length: cint; 
                         num_iso_packets: cint; callback: libusb_transfer_cb_fn; 
                         user_data: pointer; timeout: cuint)"><wbr />libusb_<wbr />fill_<wbr />iso_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_set_iso_packet_lengths,ptr.libusb_transfer,cuint"
    title="libusb_set_iso_packet_lengths(transfer: ptr libusb_transfer; length: cuint)"><wbr />libusb_<wbr />set_<wbr />iso_<wbr />packet_<wbr />lengths</a></li>
  <li><a class="reference" href="#libusb_get_iso_packet_buffer,ptr.libusb_transfer,cuint"
    title="libusb_get_iso_packet_buffer(transfer: ptr libusb_transfer; packet: cuint): ptr cuchar"><wbr />libusb_<wbr />get_<wbr />iso_<wbr />packet_<wbr />buffer</a></li>
  <li><a class="reference" href="#libusb_get_iso_packet_buffer_simple,ptr.libusb_transfer,cuint"
    title="libusb_get_iso_packet_buffer_simple(transfer: ptr libusb_transfer; packet: cuint): ptr cuchar"><wbr />libusb_<wbr />get_<wbr />iso_<wbr />packet_<wbr />buffer_<wbr />simple</a></li>
  <li><a class="reference" href="#libusb_control_transfer,ptr.libusb_device_handle,libusb_endpoint_direction,libusb_standard_request,uint16,uint16,ptr.cuchar,uint16,cuint"
    title="libusb_control_transfer(dev_handle: ptr libusb_device_handle; 
                        request_type: libusb_endpoint_direction; 
                        bRequest: libusb_standard_request; wValue: uint16; 
                        wIndex: uint16; data: ptr cuchar; wLength: uint16; 
                        timeout: cuint): cint"><wbr />libusb_<wbr />control_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_bulk_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"
    title="libusb_bulk_transfer(dev_handle: ptr libusb_device_handle; endpoint: cuchar; 
                     data: ptr cuchar; length: cint; actual_length: ptr cint; 
                     timeout: cuint): cint"><wbr />libusb_<wbr />bulk_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_interrupt_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"
    title="libusb_interrupt_transfer(dev_handle: ptr libusb_device_handle; 
                          endpoint: cuchar; data: ptr cuchar; length: cint; 
                          actual_length: ptr cint; timeout: cuint): cint"><wbr />libusb_<wbr />interrupt_<wbr />transfer</a></li>
  <li><a class="reference" href="#libusb_get_descriptor,ptr.libusb_device_handle,uint8,uint8,ptr.cuchar,cint"
    title="libusb_get_descriptor(dev: ptr libusb_device_handle; desc_type: uint8; 
                      desc_index: uint8; data: ptr cuchar; length: cint): cint"><wbr />libusb_<wbr />get_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_string_descriptor,ptr.libusb_device_handle,uint8,uint16,ptr.cuchar,cint"
    title="libusb_get_string_descriptor(dev: ptr libusb_device_handle; desc_index: uint8; 
                             langid: uint16; data: ptr cuchar; length: cint): cint"><wbr />libusb_<wbr />get_<wbr />string_<wbr />descriptor</a></li>
  <li><a class="reference" href="#libusb_get_string_descriptor_ascii,ptr.libusb_device_handle,uint8,ptr.cuchar,cint"
    title="libusb_get_string_descriptor_ascii(dev: ptr libusb_device_handle; 
                                   desc_index: uint8; data: ptr cuchar; 
                                   length: cint): cint"><wbr />libusb_<wbr />get_<wbr />string_<wbr />descriptor_<wbr />ascii</a></li>
  <li><a class="reference" href="#libusb_try_lock_events,ptr.libusb_context"
    title="libusb_try_lock_events(ctx: ptr libusb_context): cint"><wbr />libusb_<wbr />try_<wbr />lock_<wbr />events</a></li>
  <li><a class="reference" href="#libusb_lock_events,ptr.libusb_context"
    title="libusb_lock_events(ctx: ptr libusb_context)"><wbr />libusb_<wbr />lock_<wbr />events</a></li>
  <li><a class="reference" href="#libusb_unlock_events,ptr.libusb_context"
    title="libusb_unlock_events(ctx: ptr libusb_context)"><wbr />libusb_<wbr />unlock_<wbr />events</a></li>
  <li><a class="reference" href="#libusb_event_handling_ok,ptr.libusb_context"
    title="libusb_event_handling_ok(ctx: ptr libusb_context): cint"><wbr />libusb_<wbr />event_<wbr />handling_<wbr />ok</a></li>
  <li><a class="reference" href="#libusb_event_handler_active,ptr.libusb_context"
    title="libusb_event_handler_active(ctx: ptr libusb_context): cint"><wbr />libusb_<wbr />event_<wbr />handler_<wbr />active</a></li>
  <li><a class="reference" href="#libusb_lock_event_waiters,ptr.libusb_context"
    title="libusb_lock_event_waiters(ctx: ptr libusb_context)"><wbr />libusb_<wbr />lock_<wbr />event_<wbr />waiters</a></li>
  <li><a class="reference" href="#libusb_unlock_event_waiters,ptr.libusb_context"
    title="libusb_unlock_event_waiters(ctx: ptr libusb_context)"><wbr />libusb_<wbr />unlock_<wbr />event_<wbr />waiters</a></li>
  <li><a class="reference" href="#libusb_wait_for_event,ptr.libusb_context,ptr.timeval"
    title="libusb_wait_for_event(ctx: ptr libusb_context; tv: ptr timeval): cint"><wbr />libusb_<wbr />wait_<wbr />for_<wbr />event</a></li>
  <li><a class="reference" href="#libusb_handle_events_timeout_completed,ptr.libusb_context,ptr.timeval,ptr.cint"
    title="libusb_handle_events_timeout_completed(ctx: ptr libusb_context; tv: ptr timeval; 
                                       completed: ptr cint): cint"><wbr />libusb_<wbr />handle_<wbr />events_<wbr />timeout_<wbr />completed</a></li>
  <li><a class="reference" href="#libusb_handle_events_completed,ptr.libusb_context,ptr.cint"
    title="libusb_handle_events_completed(ctx: ptr libusb_context; completed: ptr cint): cint"><wbr />libusb_<wbr />handle_<wbr />events_<wbr />completed</a></li>
  <li><a class="reference" href="#libusb_handle_events_locked,ptr.libusb_context,ptr.timeval"
    title="libusb_handle_events_locked(ctx: ptr libusb_context; tv: ptr timeval): cint"><wbr />libusb_<wbr />handle_<wbr />events_<wbr />locked</a></li>
  <li><a class="reference" href="#libusb_pollfds_handle_timeouts,ptr.libusb_context"
    title="libusb_pollfds_handle_timeouts(ctx: ptr libusb_context): cint"><wbr />libusb_<wbr />pollfds_<wbr />handle_<wbr />timeouts</a></li>
  <li><a class="reference" href="#libusb_get_next_timeout,ptr.libusb_context,ptr.timeval"
    title="libusb_get_next_timeout(ctx: ptr libusb_context; tv: ptr timeval): cint"><wbr />libusb_<wbr />get_<wbr />next_<wbr />timeout</a></li>
  <li><a class="reference" href="#libusb_get_pollfds,ptr.libusb_context"
    title="libusb_get_pollfds(ctx: ptr libusb_context): ptr ptr libusb_pollfd"><wbr />libusb_<wbr />get_<wbr />pollfds</a></li>
  <li><a class="reference" href="#libusb_set_pollfd_notifiers,ptr.libusb_context,libusb_pollfd_added_cb,libusb_pollfd_removed_cb,pointer"
    title="libusb_set_pollfd_notifiers(ctx: ptr libusb_context; 
                            added_cb: libusb_pollfd_added_cb; 
                            removed_cb: libusb_pollfd_removed_cb; 
                            user_data: pointer)"><wbr />libusb_<wbr />set_<wbr />pollfd_<wbr />notifiers</a></li>
  <li><a class="reference" href="#libusb_hotplug_register_callback,ptr.libusb_context,libusb_hotplug_event,libusb_hotplug_flag,cint,cint,cint,libusb_hotplug_callback_fn,pointer,ptr.libusb_hotplug_callback_handle"
    title="libusb_hotplug_register_callback(ctx: ptr libusb_context; 
                                 events: libusb_hotplug_event; 
                                 flags: libusb_hotplug_flag; vendor_id: cint; 
                                 product_id: cint; dev_class: cint; 
                                 cb_fn: libusb_hotplug_callback_fn; 
                                 user_data: pointer; 
                                 handle: ptr libusb_hotplug_callback_handle): cint"><wbr />libusb_<wbr />hotplug_<wbr />register_<wbr />callback</a></li>
  <li><a class="reference" href="#libusb_hotplug_deregister_callback,ptr.libusb_context,libusb_hotplug_callback_handle"
    title="libusb_hotplug_deregister_callback(ctx: ptr libusb_context; 
                                   handle: libusb_hotplug_callback_handle)"><wbr />libusb_<wbr />hotplug_<wbr />deregister_<wbr />callback</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libusb_le16_to_cpu.t,uint16"
    title="libusb_le16_to_cpu(x: uint16): uint16"><wbr />libusb_<wbr />le16_<wbr />to_<wbr />cpu</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"></p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="endians.html">endians</a>, <a class="reference external" href="unsigned.html">unsigned</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<dt id="timeval"><a name="timeval"></a><pre><span class="Identifier">timeval</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">tv_sec</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">clong</span>
  <span class="Identifier">tv_usec</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">clong</span>
</pre></dt>
<dd>
Specifies a time interval.

</dd>
<dt id="libusb_class_code"><a name="libusb_class_code"></a><pre><span class="Identifier">libusb_class_code</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_CLASS_PER_INTERFACE</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Comment">## each interface has its own class</span>
  <span class="Identifier">LIBUSB_CLASS_AUDIO</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>     <span class="Comment">## Audio class</span>
  <span class="Identifier">LIBUSB_CLASS_COMM</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>      <span class="Comment">## Communications class</span>
  <span class="Identifier">LIBUSB_CLASS_HID</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>       <span class="Comment">## Human Interface Device class</span>
  <span class="Identifier">LIBUSB_CLASS_PHYSICAL</span> <span class="Other">=</span> <span class="DecNumber">5</span><span class="Other">,</span>  <span class="Comment">## Physical</span>
  <span class="Identifier">LIBUSB_CLASS_IMAGE</span> <span class="Other">=</span> <span class="DecNumber">6</span><span class="Other">,</span>     <span class="Comment">## Image class</span>
  <span class="Identifier">LIBUSB_CLASS_PRINTER</span> <span class="Other">=</span> <span class="DecNumber">7</span><span class="Other">,</span>   <span class="Comment">## Printer class</span>
  <span class="Identifier">LIBUSB_CLASS_MASS_STORAGE</span> <span class="Other">=</span> <span class="DecNumber">8</span><span class="Other">,</span> <span class="Comment">## Image class</span>
  <span class="Identifier">LIBUSB_CLASS_HUB</span> <span class="Other">=</span> <span class="DecNumber">9</span><span class="Other">,</span>       <span class="Comment">## Hub class</span>
  <span class="Identifier">LIBUSB_CLASS_DATA</span> <span class="Other">=</span> <span class="DecNumber">10</span><span class="Other">,</span>     <span class="Comment">## Data class</span>
  <span class="Identifier">LIBUSB_CLASS_SMART_CARD</span> <span class="Other">=</span> <span class="DecNumber">0x0000000B</span><span class="Other">,</span> <span class="Comment">## Smart Card</span>
  <span class="Identifier">LIBUSB_CLASS_CONTENT_SECURITY</span> <span class="Other">=</span> <span class="DecNumber">0x0000000D</span><span class="Other">,</span> <span class="Comment">## Content Security</span>
  <span class="Identifier">LIBUSB_CLASS_VIDEO</span> <span class="Other">=</span> <span class="DecNumber">0x0000000E</span><span class="Other">,</span> <span class="Comment">## Video</span>
  <span class="Identifier">LIBUSB_CLASS_PERSONAL_HEALTHCARE</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span><span class="Other">,</span> <span class="Comment">## Personal Healthcare</span>
  <span class="Identifier">LIBUSB_CLASS_DIAGNOSTIC_DEVICE</span> <span class="Other">=</span> <span class="DecNumber">0x000000DC</span><span class="Other">,</span> <span class="Comment">## Diagnostic Device</span>
  <span class="Identifier">LIBUSB_CLASS_WIRELESS</span> <span class="Other">=</span> <span class="DecNumber">0x000000E0</span><span class="Other">,</span> <span class="Comment">## Wireless class</span>
  <span class="Identifier">LIBUSB_CLASS_APPLICATION</span> <span class="Other">=</span> <span class="DecNumber">0x000000FE</span><span class="Other">,</span> <span class="Comment">## Application class</span>
  <span class="Identifier">LIBUSB_CLASS_VENDOR_SPEC</span> <span class="Other">=</span> <span class="DecNumber">0x000000FF</span> <span class="Comment">## Class is vendor-specific</span></pre></dt>
<dd>

Enumerates USB device class codes.

</dd>
<dt id="libusb_descriptor_type"><a name="libusb_descriptor_type"></a><pre><span class="Identifier">libusb_descriptor_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_DT_DEVICE</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## Device descriptor (see `libusb_device_descriptor`)</span>
  <span class="Identifier">LIBUSB_DT_CONFIG</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span> <span class="Comment">## Configuration descriptor (see `libusb_config_descriptor`)</span>
  <span class="Identifier">LIBUSB_DT_STRING</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span><span class="Other">,</span> <span class="Comment">## String descriptor</span>
  <span class="Identifier">LIBUSB_DT_INTERFACE</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span><span class="Other">,</span> <span class="Comment">## Interface descriptor. See libusb_interface_descriptor</span>
  <span class="Identifier">LIBUSB_DT_ENDPOINT</span> <span class="Other">=</span> <span class="DecNumber">0x00000005</span><span class="Other">,</span> <span class="Comment">## Endpoint descriptor. See libusb_endpoint_descriptor</span>
  <span class="Identifier">LIBUSB_DT_BOS</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span><span class="Other">,</span> <span class="Comment">## BOS descriptor</span>
  <span class="Identifier">LIBUSB_DT_DEVICE_CAPABILITY</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span><span class="Other">,</span> <span class="Comment">## Device Capability descriptor</span>
  <span class="Identifier">LIBUSB_DT_HID</span> <span class="Other">=</span> <span class="DecNumber">0x00000021</span><span class="Other">,</span> <span class="Comment">## HID descriptor</span>
  <span class="Identifier">LIBUSB_DT_REPORT</span> <span class="Other">=</span> <span class="DecNumber">0x00000022</span><span class="Other">,</span> <span class="Comment">## HID report descriptor</span>
  <span class="Identifier">LIBUSB_DT_PHYSICAL</span> <span class="Other">=</span> <span class="DecNumber">0x00000023</span><span class="Other">,</span> <span class="Comment">## Physical descriptor</span>
  <span class="Identifier">LIBUSB_DT_HUB</span> <span class="Other">=</span> <span class="DecNumber">0x00000029</span><span class="Other">,</span> <span class="Comment">## Hub descriptor</span>
  <span class="Identifier">LIBUSB_DT_SUPERSPEED_HUB</span> <span class="Other">=</span> <span class="DecNumber">0x0000002A</span><span class="Other">,</span> <span class="Comment">## SuperSpeed Hub descriptor</span>
  <span class="Identifier">LIBUSB_DT_SS_ENDPOINT_COMPANION</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span> <span class="Comment">## SuperSpeed Endpoint Companion descriptor</span></pre></dt>
<dd>

Enumerates device descriptor types.

</dd>
<dt id="libusb_endpoint_direction"><a name="libusb_endpoint_direction"></a><pre><span class="Identifier">libusb_endpoint_direction</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_ENDPOINT_OUT</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span> <span class="Comment">## In: device-to-host</span>
  <span class="Identifier">LIBUSB_ENDPOINT_IN</span> <span class="Other">=</span> <span class="DecNumber">0x00000080</span> <span class="Comment">## Out: host-to-device</span></pre></dt>
<dd>

Enumerates available endpoint directions (bit 7 of the libusb_endpoint_descriptor.bEndpointAddress scheme)

</dd>
<dt id="libusb_transfer_type"><a name="libusb_transfer_type"></a><pre><span class="Identifier">libusb_transfer_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_TRANSFER_TYPE_CONTROL</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">LIBUSB_TRANSFER_TYPE_ISOCHRONOUS</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Isochronous endpoint</span>
  <span class="Identifier">LIBUSB_TRANSFER_TYPE_BULK</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Bulk endpoint</span>
  <span class="Identifier">LIBUSB_TRANSFER_TYPE_INTERRUPT</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span> <span class="Comment">## Interrupt endpoint</span>
  <span class="Identifier">LIBUSB_TRANSFER_TYPE_BULK_STREAM</span> <span class="Other">=</span> <span class="DecNumber">4</span> <span class="Comment">## Stream endpoint</span></pre></dt>
<dd>

Enumerates endpoint transfer types.

</dd>
<dt id="libusb_standard_request"><a name="libusb_standard_request"></a><pre><span class="Identifier">libusb_standard_request</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_REQUEST_GET_STATUS</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span> <span class="Comment">## Request status of the specific recipient</span>
  <span class="Identifier">LIBUSB_REQUEST_CLEAR_FEATURE</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## Clear or disable a specific feature</span>
  <span class="Identifier">LIBUSB_REQUEST_RESERVED2</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span> <span class="Comment">## Reserved for future use</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_FEATURE</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span><span class="Other">,</span> <span class="Comment">## Set or enable a specific feature</span>
  <span class="Identifier">LIBUSB_REQUEST_RESERVED4</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span><span class="Other">,</span> <span class="Comment">## Reserved for future use</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_ADDRESS</span> <span class="Other">=</span> <span class="DecNumber">0x00000005</span><span class="Other">,</span> <span class="Comment">## Set device address for all future accesses</span>
  <span class="Identifier">LIBUSB_REQUEST_GET_DESCRIPTOR</span> <span class="Other">=</span> <span class="DecNumber">0x00000006</span><span class="Other">,</span> <span class="Comment">## Get the specified descriptor</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_DESCRIPTOR</span> <span class="Other">=</span> <span class="DecNumber">0x00000007</span><span class="Other">,</span> <span class="Comment">## Used to update existing \</span>
                                              <span class="Comment">## descriptors or add new descriptors</span>
  <span class="Identifier">LIBUSB_REQUEST_GET_CONFIGURATION</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span><span class="Other">,</span> <span class="Comment">## Get the current device \</span>
                                                 <span class="Comment">## configuration value</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_CONFIGURATION</span> <span class="Other">=</span> <span class="DecNumber">0x00000009</span><span class="Other">,</span> <span class="Comment">## Set device configuration</span>
  <span class="Identifier">LIBUSB_REQUEST_GET_INTERFACE</span> <span class="Other">=</span> <span class="DecNumber">0x0000000A</span><span class="Other">,</span> <span class="Comment">## Return the selected \</span>
                                             <span class="Comment">## alternate setting for the specified interface</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_INTERFACE</span> <span class="Other">=</span> <span class="DecNumber">0x0000000B</span><span class="Other">,</span> <span class="Comment">## Select an alternate \</span>
                                             <span class="Comment">## interface for the specified interface</span>
  <span class="Identifier">LIBUSB_REQUEST_SYNCH_FRAME</span> <span class="Other">=</span> <span class="DecNumber">0x0000000C</span><span class="Other">,</span> <span class="Comment">## Set then report an endpoint's \</span>
                                           <span class="Comment">## synchronization frame</span>
  <span class="Identifier">LIBUSB_REQUEST_SET_SEL</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span><span class="Other">,</span> <span class="Comment">## Sets both the U1 and U2 Exit Latency</span>
  <span class="Identifier">LIBUSB_SET_ISOCH_DELAY</span> <span class="Other">=</span> <span class="DecNumber">0x00000031</span> <span class="Comment">## Delay from the time a host \</span>
                                      <span class="Comment">## transmits a packet to the time it is received by the device</span></pre></dt>
<dd>

Enumerates standard requests as defined in table 9-5 of the USB 3.0 spec.

</dd>
<dt id="libusb_request_type"><a name="libusb_request_type"></a><pre><span class="Identifier">libusb_request_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_REQUEST_TYPE_STANDARD</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000000</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Standard</span>
  <span class="Identifier">LIBUSB_REQUEST_TYPE_CLASS</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000001</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Class</span>
  <span class="Identifier">LIBUSB_REQUEST_TYPE_VENDOR</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000002</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Vendor</span>
  <span class="Identifier">LIBUSB_REQUEST_TYPE_RESERVED</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000003</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span> <span class="Comment">## Reserved</span></pre></dt>
<dd>

Enumerates standard requests, as defined in table 9-5 of the USB 3.0 spec.

</dd>
<dt id="libusb_request_recipient"><a name="libusb_request_recipient"></a><pre><span class="Identifier">libusb_request_recipient</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_RECIPIENT_DEVICE</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span> <span class="Comment">## Device</span>
  <span class="Identifier">LIBUSB_RECIPIENT_INTERFACE</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## Interface</span>
  <span class="Identifier">LIBUSB_RECIPIENT_ENDPOINT</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span> <span class="Comment">## Endpoint</span>
  <span class="Identifier">LIBUSB_RECIPIENT_OTHER</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span> <span class="Comment">## Other</span></pre></dt>
<dd>

Enumerates recipient bits in the libusb_control_setup.bmRequestType 
field. Values 4 through 31 are reserved.

</dd>
<dt id="libusb_iso_sync_type"><a name="libusb_iso_sync_type"></a><pre><span class="Identifier">libusb_iso_sync_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_ISO_SYNC_TYPE_NONE</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Comment">## No synchronization</span>
  <span class="Identifier">LIBUSB_ISO_SYNC_TYPE_ASYNC</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Asynchronous</span>
  <span class="Identifier">LIBUSB_ISO_SYNC_TYPE_ADAPTIVE</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Adaptive</span>
  <span class="Identifier">LIBUSB_ISO_SYNC_TYPE_SYNC</span> <span class="Other">=</span> <span class="DecNumber">3</span> <span class="Comment">## Synchronous</span></pre></dt>
<dd>

Enumerates synchronization types for isochronous endpoints.

</dd>
<dt id="libusb_iso_usage_type"><a name="libusb_iso_usage_type"></a><pre><span class="Identifier">libusb_iso_usage_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_ISO_USAGE_TYPE_DATA</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Comment">## Data endpoint</span>
  <span class="Identifier">LIBUSB_ISO_USAGE_TYPE_FEEDBACK</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Feedback endpoint</span>
  <span class="Identifier">LIBUSB_ISO_USAGE_TYPE_IMPLICIT</span> <span class="Other">=</span> <span class="DecNumber">2</span> <span class="Comment">## Implicit feedback Data endpoint</span></pre></dt>
<dd>

Enumerates usage types for isochronous endpoints.

</dd>
<dt id="libusb_device_descriptor"><a name="libusb_device_descriptor"></a><pre><span class="Identifier">libusb_device_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes)</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_DEVICE).</span>
  <span class="Identifier">bcdUSB</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Comment">## USB specification release number in binary-coded \</span>
                  <span class="Comment">## decimal. 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc.</span>
  <span class="Identifier">bDeviceClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>        <span class="Comment">## USB-IF class code for the device.</span>
                              <span class="Comment">## See `libusb_class_code`.</span>
  <span class="Identifier">bDeviceSubClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## USB-IF subclass code for the device, qualified \</span>
                          <span class="Comment">## by the bDeviceClass value.</span>
  <span class="Identifier">bDeviceProtocol</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## USB-IF protocol code for the device, qualified \</span>
                          <span class="Comment">## by the bDeviceClass and bDeviceSubClass values.</span>
  <span class="Identifier">bMaxPacketSize0</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Maximum packet size for endpoint 0</span>
  <span class="Identifier">idVendor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>           <span class="Comment">## USB-IF vendor ID</span>
  <span class="Identifier">idProduct</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>          <span class="Comment">## USB-IF product ID</span>
  <span class="Identifier">bcdDevice</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>          <span class="Comment">## Device release number in binary-coded decimal</span>
  <span class="Identifier">iManufacturer</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Index of string descriptor describing manufacturer</span>
  <span class="Identifier">iProduct</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>            <span class="Comment">## Index of string descriptor describing product</span>
  <span class="Identifier">iSerialNumber</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Index of string descriptor containing device \</span>
                              <span class="Comment">## serial number</span>
  <span class="Identifier">bNumConfigurations</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Number of possible configurations</span>
  </pre></dt>
<dd>
Standard USB device descriptor. This descriptor is documented in section 9.6.1 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_endpoint_descriptor"><a name="libusb_endpoint_descriptor"></a><pre><span class="Identifier">libusb_endpoint_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_ENDPOINT).</span>
  <span class="Identifier">bEndpointAddress</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The address of the endpoint described by this</span>
                           <span class="Comment">## descriptor. Bits 0:3 are the endpoint number. Bits 4:6 are reserved.</span>
                           <span class="Comment">## Bit 7 indicates direction, see `libusb_endpoint_direction`.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Attributes which apply to the endpoint when it is</span>
                       <span class="Comment">## configured using the bConfigurationValue. Bits 0:1 determine the</span>
                       <span class="Comment">## transfer type and correspond to `libusb_transfer_type`. Bits 2:3 are</span>
                       <span class="Comment">## only used for isochronous endpoints and correspond to</span>
                       <span class="Comment">## `libusb_iso_sync_type`. Bits 4:5 are also only used for isochronous</span>
                       <span class="Comment">## endpoints and correspond to `libusb_iso_usage_type1`. Bits 6:7 are</span>
                       <span class="Comment">## reserved.</span>
  <span class="Identifier">wMaxPacketSize</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>     <span class="Comment">## Maximum packet size this endpoint is capable of</span>
                              <span class="Comment">## sending/receiving.</span>
  <span class="Identifier">bInterval</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>           <span class="Comment">## Interval for polling endpoint for data transfers.</span>
  <span class="Identifier">bRefresh</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>            <span class="Comment">## For audio devices only: the rate at which</span>
                              <span class="Comment">## synchronization feedback is provided.</span>
  <span class="Identifier">bSynchAddress</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## For audio devices only: the address if the synch</span>
                        <span class="Comment">## endpoint</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## endpoint descriptors, it will store them here, should you wish to parse</span>
                  <span class="Comment">## them.</span>
  <span class="Identifier">extra_length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>         <span class="Comment">## Length of the extra descriptors, in bytes</span>
  </pre></dt>
<dd>
Standard USB endpoint descriptor. This descriptor is documented in section 9.6.6 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_interface_descriptor"><a name="libusb_interface_descriptor"></a><pre><span class="Identifier">libusb_interface_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_INTERFACE).</span>
  <span class="Identifier">bInterfaceNumber</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>    <span class="Comment">## Number of this interface.</span>
  <span class="Identifier">bAlternateSetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Value used to select this alternate setting for</span>
                              <span class="Comment">## this interface</span>
  <span class="Identifier">bNumEndpoints</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Number of endpoints used by this interface</span>
                              <span class="Comment">## (excluding the control endpoint).</span>
  <span class="Identifier">bInterfaceClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## USB-IF class code for this interface</span>
                              <span class="Comment">## (see `libusb_class_code`)</span>
  <span class="Identifier">bInterfaceSubClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## USB-IF subclass code for this interface,</span>
                              <span class="Comment">## qualified by the bInterfaceClass value.</span>
  <span class="Identifier">bInterfaceProtocol</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## USB-IF protocol code for this interface,</span>
                              <span class="Comment">## qualified by the bInterfaceClass and bInterfaceSubClass values.</span>
  <span class="Identifier">iInterface</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>          <span class="Comment">## Index of string descriptor describing this interface.</span>
  <span class="Identifier">endpoint</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_endpoint_descriptor</span> <span class="Comment">## Array of endpoint descriptors.</span>
                                            <span class="Comment">## This length of this array is determined by the bNumEndpoints field.</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## interface descriptors, it will store them here, should you wish to</span>
                  <span class="Comment">## parse them.</span>
  <span class="Identifier">extra_length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>         <span class="Comment">## Length of the extra descriptors, in bytes.</span>
  </pre></dt>
<dd>
A structure representing the standard USB interface descriptor. This descriptor is documented in section 9.6.5 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_interface"><a name="libusb_interface"></a><pre><span class="Identifier">libusb_interface</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">altsetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_interface_descriptor</span> <span class="Comment">## Array of interface</span>
                                               <span class="Comment">## descriptors. The length of this array is determined by the</span>
                                               <span class="Comment">## `num_altsetting` field.</span>
  <span class="Identifier">num_altsetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>       <span class="Comment">## The number of alternate settings that belong to</span>
                              <span class="Comment">## this interface.</span>
  </pre></dt>
<dd>
Collection of alternate settings for a particular USB interface.

</dd>
<dt id="libusb_config_descriptor"><a name="libusb_config_descriptor"></a><pre><span class="Identifier">libusb_config_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_CONFIG).</span>
  <span class="Identifier">wTotalLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>       <span class="Comment">## Total length of data returned for this configuration.</span>
  <span class="Identifier">bNumInterfaces</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Number of interfaces supported by this configuration.</span>
  <span class="Identifier">bConfigurationValue</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Identifier value for this configuration.</span>
  <span class="Identifier">iConfiguration</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Index of string descriptor describing this configuration.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>        <span class="Comment">## Configuration characteristics</span>
  <span class="Identifier">MaxPower</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Maximum power consumption of the USB device from this</span>
                   <span class="Comment">## bus in this configuration when the device is fully opreation.</span>
                   <span class="Comment">## Expressed in units of 2 mA.</span>
  <span class="Identifier">interfaces</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_interface</span> <span class="Comment">## Array of interfaces supported by this</span>
                                    <span class="Comment">## configuration. The length of this array is determined by the</span>
                                    <span class="Comment">## `bNumInterfaces` field.</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## configuration descriptors, it will store them here, should you wish to</span>
                  <span class="Comment">## parse them.</span>
  <span class="Identifier">extra_length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>         <span class="Comment">## Length of the extra descriptors, in bytes.</span>
  </pre></dt>
<dd>
A structure representing the standard USB configuration descriptor. This descriptor is documented in section 9.6.3 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_ss_endpoint_companion_descriptor"><a name="libusb_ss_endpoint_companion_descriptor"></a><pre><span class="Identifier">libusb_ss_endpoint_companion_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor.</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_SS_ENDPOINT_COMPANION).</span>
  <span class="Identifier">bMaxBurst</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The maximum number of packets the endpoint can send or</span>
                    <span class="Comment">## recieve as part of a burst.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## In bulk EP: bits 4:0 represents the maximum number</span>
                       <span class="Comment">## of streams the EP supports. In isochronous EP: bits 1:0 represents the</span>
                       <span class="Comment">## Mult - a zero based value that determines the maximum number of packets</span>
                       <span class="Comment">## within a service interval.</span>
  <span class="Identifier">wBytesPerInterval</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>  <span class="Comment">## The total number of bytes this EP will</span>
                              <span class="Comment">## transfer every service interval. valid only for periodic EPs.</span>
  </pre></dt>
<dd>
A structure representing the superspeed endpoint companion descriptor. This descriptor is documented in section 9.6.7 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_bos_dev_capability_descriptor"><a name="libusb_bos_dev_capability_descriptor"></a><pre><span class="Identifier">libusb_bos_dev_capability_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bDevCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Device Capability type.</span>
  <span class="Identifier">dev_capability_data</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">uint8</span><span class="Other">]</span> <span class="Comment">## Device Capability data (bLength - 3 bytes).</span>
  </pre></dt>
<dd>
Generic representation of a BOS Device Capability descriptor. It is advised to check bDevCapabilityType and call the matching <cite>libusb_get_*_descriptor</cite> function to get a structure fully matching the type.

</dd>
<dt id="libusb_bos_descriptor"><a name="libusb_bos_descriptor"></a><pre><span class="Identifier">libusb_bos_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_BOS).</span>
  <span class="Identifier">wTotalLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>       <span class="Comment">## Length of this descriptor and all of its sub descriptors.</span>
  <span class="Identifier">bNumDeviceCaps</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## The number of separate device capability</span>
                              <span class="Comment">## descriptors in the BOS.</span>
  <span class="Identifier">dev_capability</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">,</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_dev_capability_descriptor</span><span class="Other">]</span> <span class="Comment">## \</span>
                                                                      <span class="Comment">## `bNumDeviceCap` Device Capability Descriptors.</span>
  </pre></dt>
<dd>
Binary Device Object Store (BOS) descriptor. This descriptor is documented in section 9.6.2 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_usb_2_0_extension_descriptor"><a name="libusb_usb_2_0_extension_descriptor"></a><pre><span class="Identifier">libusb_usb_2_0_extension_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bDevCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Capability type (LIBUSB_BT_USB_2_0_EXTENSION).</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Comment">## Bitmap encoding of supported device level features.</span>
                        <span class="Comment">## A value of one in a bit location indicates a feature is supported; a</span>
                        <span class="Comment">## value of zero indicates it is not supported.</span>
                        <span class="Comment">## See `libusb_usb_2_0_extension_attributes`.</span>
  </pre></dt>
<dd>
USB 2.0 Extension descriptor. This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.

</dd>
<dt id="libusb_ss_usb_device_capability_descriptor"><a name="libusb_ss_usb_device_capability_descriptor"></a><pre><span class="Identifier">libusb_ss_usb_device_capability_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bDevCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Capability type (LIBUSB_BT_SS_USB_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Bitmap encoding of supported device level features.</span>
                       <span class="Comment">## A value of one in a bit location indicates a feature is supported; a</span>
                       <span class="Comment">## value of zero indicates it is not supported.</span>
                       <span class="Comment">## See `libusb_ss_usb_device_capability_attributes`.</span>
  <span class="Identifier">wSpeedSupported</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>    <span class="Comment">## Bitmap encoding of the speed supported by this</span>
                              <span class="Comment">## device when operating in SuperSpeed mode. See `libusb_supported_speed`.</span>
  <span class="Identifier">bFunctionalitySupport</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The lowest speed at which all the</span>
                                <span class="Comment">## functionality supported by the device is available to the user.</span>
                                <span class="Comment">## For example if the device supports all its functionality when connected</span>
                                <span class="Comment">## at full speed and above then it sets this value to 1.</span>
  <span class="Identifier">bU1DevExitLat</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## U1 Device Exit Latency.</span>
  <span class="Identifier">bU2DevExitLat</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>      <span class="Comment">## U2 Device Exit Latency.</span>
  </pre></dt>
<dd>
Container ID descriptor. This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification. All multiple-byte fields, except UUIDs, are represented in host-endian format.

</dd>
<dt id="libusb_container_id_descriptor"><a name="libusb_container_id_descriptor"></a><pre><span class="Identifier">libusb_container_id_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">bDescriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Descriptor type (LIBUSB_DT_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bDevCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Capability type (LIBUSB_BT_CONTAINER_ID).</span>
  <span class="Identifier">bReserved</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>           <span class="Comment">## Reserved for future use.</span>
  <span class="Identifier">ContainerID</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">16</span><span class="Other">,</span> <span class="Identifier">uint8</span><span class="Other">]</span> <span class="Comment">## 128 bit UUID.</span>
  </pre></dt>
<dd>
A structure representing the Container ID descriptor. This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification. All multiple-byte fields, except UUIDs, are represented in host-endian format.

</dd>
<dt id="libusb_control_setup"><a name="libusb_control_setup"></a><pre><span class="Identifier">libusb_control_setup</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bmRequestType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Request type. Bits 0:4 determine recipient, see</span>
                        <span class="Comment">## `libusb_request_recipient`. Bits 5:6 determine type, see</span>
                        <span class="Comment">## `libusb_request_type`. Bit 7 determines data transfer direction, see</span>
                        <span class="Comment">## `libusb_endpoint_direction`.</span>
  <span class="Identifier">bRequest</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Request. If the type bits of `bmRequestType` are equal</span>
                   <span class="Comment">## to `LIBUSB_REQUEST_TYPE_STANDARD` then this field refers to</span>
                   <span class="Comment">## `libusb_standard_request`. For other cases, use of this field is</span>
                   <span class="Comment">## application-specific.</span>
  <span class="Identifier">wValue</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>             <span class="Comment">## Value. Varies according to request.</span>
  <span class="Identifier">wIndex</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Comment">## Index. Varies according to request, typically used to</span>
                  <span class="Comment">## pass an index or offset</span>
  <span class="Identifier">wLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>            <span class="Comment">## Number of bytes to transfer.</span>
  </pre></dt>
<dd>
Setup packet for control transfers.

</dd>
<dt id="libusb_version"><a name="libusb_version"></a><pre><span class="Identifier">libusb_version</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">major</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library major version.</span>
  <span class="Identifier">minor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library minor version.</span>
  <span class="Identifier">micro</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library micro version.</span>
  <span class="Identifier">nano</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>               <span class="Comment">## Library nano version.</span>
  <span class="Identifier">rc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>                <span class="Comment">## Library release candidate suffix string, e.g. &quot;-rc4&quot;.</span>
  <span class="Identifier">describe</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>          <span class="Comment">## For ABI compatibility only.</span>
  </pre></dt>
<dd>
Provides the version of the libusb runtime.

</dd>
<dt id="libusb_context"><a name="libusb_context"></a><pre><span class="Identifier">libusb_context</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
<p>Structure representing a libusb session. The concept of individual libusb sessions allows for your program to use two libraries (or dynamically load two modules) which both independently use libusb. This will prevent interference between the individual libusb users - for example <cite>libusb_set_debug()</cite> will not affect the other user of the library, and <cite>libusb_exit()</cite> will not destroy resources that the other user is still using.</p>
<p>Sessions are created by <cite>libusb_init()</cite> and destroyed through <cite>libusb_exit()</cite>. If your application is guaranteed to only ever include a single libusb user (i.e. you), you do not have to worry about contexts: pass nil in every function call where a context is required. The default context will be used.</p>


</dd>
<dt id="libusb_device"><a name="libusb_device"></a><pre><span class="Identifier">libusb_device</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
<p>Structure representing a USB device detected on the system. This is an opaque type for which you are only ever provided with a pointer, usually originating from <cite>libusb_get_device_list()</cite>.</p>
<p>Certain operations can be performed on a device, but in order to do any I/O you will have to first obtain a device handle using <cite>libusb_open()</cite>.</p>
<p>Devices are reference counted with <cite>libusb_ref_device()</cite> and <cite>libusb_unref_device()</cite>, and are freed when the reference count reaches</p>
<p>0. New devices presented by <cite>libusb_get_device_list()</cite> have a reference count of 1, and <cite>libusb_free_device_list()</cite> can optionally decrease the reference count on all devices in the list. <cite>libusb_open()</cite> adds another reference which is later destroyed by <cite>libusb_close()</cite>.</p>


</dd>
<dt id="libusb_device_array"><a name="libusb_device_array"></a><pre><span class="Identifier">libusb_device_array</span> <span class="Other">=</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">10000</span><span class="Other">,</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">]</span></pre></dt>
<dd>
Unchecked array of pointers to USB devices.

</dd>
<dt id="libusb_device_handle"><a name="libusb_device_handle"></a><pre><span class="Identifier">libusb_device_handle</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
Represents USB device handle. This is an opaque type for which you are only ever provided with a pointer, usually originating from <cite>libusb_open()</cite>. A device handle is used to perform I/O and other operations. When finished with a device handle, you should call libusb_close().

</dd>
<dt id="libusb_speed"><a name="libusb_speed"></a><pre><span class="Identifier">libusb_speed</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_SPEED_UNKNOWN</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>   <span class="Comment">## The OS doesn't report or know the device speed.</span>
  <span class="Identifier">LIBUSB_SPEED_LOW</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>       <span class="Comment">## The device is operating at low speed (1.5MBit/s).</span>
  <span class="Identifier">LIBUSB_SPEED_FULL</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>      <span class="Comment">## The device is operating at full speed (12MBit/s).</span>
  <span class="Identifier">LIBUSB_SPEED_HIGH</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>      <span class="Comment">## The device is operating at high speed (480MBit/s).</span>
  <span class="Identifier">LIBUSB_SPEED_SUPER</span> <span class="Other">=</span> <span class="DecNumber">4</span>      <span class="Comment">##The device is operating at super speed (5000MBit/s).</span></pre></dt>
<dd>

Enumerates speed codes to indicate the speed of devices.

</dd>
<dt id="libusb_supported_speed"><a name="libusb_supported_speed"></a><pre><span class="Identifier">libusb_supported_speed</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_LOW_SPEED_OPERATION</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Low speed operation supported (1.5MBit/s).</span>
  <span class="Identifier">LIBUSB_FULL_SPEED_OPERATION</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Full speed operation supported (12MBit/s).</span>
  <span class="Identifier">LIBUSB_HIGH_SPEED_OPERATION</span> <span class="Other">=</span> <span class="DecNumber">4</span><span class="Other">,</span> <span class="Comment">## High speed operation supported (480MBit/s).</span>
  <span class="Identifier">LIBUSB_SUPER_SPEED_OPERATION</span> <span class="Other">=</span> <span class="DecNumber">8</span> <span class="Comment">## Superspeed operation supported (5000MBit/s).</span></pre></dt>
<dd>

Enumerates supported speeds in the <cite>wSpeedSupported</cite> bit field.

</dd>
<dt id="libusb_usb_2_0_extension_attributes"><a name="libusb_usb_2_0_extension_attributes"></a><pre><span class="Identifier">libusb_usb_2_0_extension_attributes</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_BM_LPM_SUPPORT</span> <span class="Other">=</span> <span class="DecNumber">2</span>   <span class="Comment">## Supports Link Power Management (LPM).</span></pre></dt>
<dd>

Masks for the bits of the <cite>libusb_usb_2_0_extension_descriptor.bmAttributes</cite> field.

</dd>
<dt id="libusb_ss_usb_device_capability_attributes"><a name="libusb_ss_usb_device_capability_attributes"></a><pre><span class="Identifier">libusb_ss_usb_device_capability_attributes</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_BM_LTM_SUPPORT</span> <span class="Other">=</span> <span class="DecNumber">2</span>   <span class="Comment">## Supports Latency Tolerance Messages (LTM).</span></pre></dt>
<dd>

Masks for the bits of the <cite>libusb_ss_usb_device_capability_descriptor.bmAttributes</cite> field.

</dd>
<dt id="libusb_bos_type"><a name="libusb_bos_type"></a><pre><span class="Identifier">libusb_bos_type</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Wireless USB device capability.</span>
  <span class="Identifier">LIBUSB_BT_USB_2_0_EXTENSION</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## USB 2.0 extensions.</span>
  <span class="Identifier">LIBUSB_BT_SS_USB_DEVICE_CAPABILITY</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span> <span class="Comment">## SuperSpeed USB device capability.</span>
  <span class="Identifier">LIBUSB_BT_CONTAINER_ID</span> <span class="Other">=</span> <span class="DecNumber">4</span>  <span class="Comment">## Container ID type.</span></pre></dt>
<dd>

Enumerates USB capability types.

</dd>
<dt id="libusb_error"><a name="libusb_error"></a><pre><span class="Identifier">libusb_error</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_ERROR_OTHER</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">99</span><span class="Other">,</span>  <span class="Comment">## Other error.</span>
  <span class="Identifier">LIBUSB_ERROR_NOT_SUPPORTED</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">12</span><span class="Other">,</span> <span class="Comment">## Operation not supported or unimplemented on this platform.</span>
  <span class="Identifier">LIBUSB_ERROR_NO_MEM</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">11</span><span class="Other">,</span> <span class="Comment">## Insufficient memory.</span>
  <span class="Identifier">LIBUSB_ERROR_INTERRUPTED</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">10</span><span class="Other">,</span> <span class="Comment">## System call interrupted (perhaps due to signal) </span>
  <span class="Identifier">LIBUSB_ERROR_PIPE</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">9</span><span class="Other">,</span>    <span class="Comment">## Pipe error.</span>
  <span class="Identifier">LIBUSB_ERROR_OVERFLOW</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">8</span><span class="Other">,</span> <span class="Comment">## Overflow.</span>
  <span class="Identifier">LIBUSB_ERROR_TIMEOUT</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">7</span><span class="Other">,</span> <span class="Comment">## Operation timed out.</span>
  <span class="Identifier">LIBUSB_ERROR_BUSY</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">6</span><span class="Other">,</span>    <span class="Comment">## Resource busy.</span>
  <span class="Identifier">LIBUSB_ERROR_NOT_FOUND</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">5</span><span class="Other">,</span> <span class="Comment">## Entity not found.</span>
  <span class="Identifier">LIBUSB_ERROR_NO_DEVICE</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">4</span><span class="Other">,</span> <span class="Comment">## No such device (it may have been disconnected).</span>
  <span class="Identifier">LIBUSB_ERROR_ACCESS</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">3</span><span class="Other">,</span>  <span class="Comment">## Access denied (insufficient permissions)</span>
  <span class="Identifier">LIBUSB_ERROR_INVALID_PARAM</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Invalid parameter.</span>
  <span class="Identifier">LIBUSB_ERROR_IO</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Other">,</span>      <span class="Comment">## Input/output error.</span>
  <span class="Identifier">LIBUSB_SUCCESS</span> <span class="Other">=</span> <span class="DecNumber">0</span>          <span class="Comment">## Success (no error).</span></pre></dt>
<dd>

Enumerates error codes.

</dd>
<dt id="libusb_transfer_status"><a name="libusb_transfer_status"></a><pre><span class="Identifier">libusb_transfer_status</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_TRANSFER_COMPLETED</span><span class="Other">,</span> <span class="Comment">## Transfer completed without error.</span>
                             <span class="Comment">## Note that this does not indicate that the entire amount of requested</span>
                             <span class="Comment">## data was transferred.</span>
  <span class="Identifier">LIBUSB_TRANSFER_ERROR</span><span class="Other">,</span>      <span class="Comment">## Transfer failed.</span>
  <span class="Identifier">LIBUSB_TRANSFER_TIMED_OUT</span><span class="Other">,</span>  <span class="Comment">## Transfer timed out.</span>
  <span class="Identifier">LIBUSB_TRANSFER_CANCELLED</span><span class="Other">,</span>  <span class="Comment">## Transfer was cancelled.</span>
  <span class="Identifier">LIBUSB_TRANSFER_STALL</span><span class="Other">,</span> <span class="Comment">## For bulk/interrupt endpoints: halt condition</span>
                         <span class="Comment">## detected (endpoint stalled). For control endpoints: control request</span>
                         <span class="Comment">## not supported.</span>
  <span class="Identifier">LIBUSB_TRANSFER_NO_DEVICE</span><span class="Other">,</span>  <span class="Comment">## Device was disconnected.</span>
  <span class="Identifier">LIBUSB_TRANSFER_OVERFLOW</span>    <span class="Comment">## Device sent more data than requested.</span></pre></dt>
<dd>

Enumerats transfer status codes.

</dd>
<dt id="libusb_transfer_flags"><a name="libusb_transfer_flags"></a><pre><span class="Identifier">libusb_transfer_flags</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_TRANSFER_SHORT_NOT_OK</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Comment">## Report short frames as errors.</span>
  <span class="Identifier">LIBUSB_TRANSFER_FREE_BUFFER</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Automatically `free()` transfer</span>
                                         <span class="Comment">## buffer during `libusb_free_transfer()`</span>
  <span class="Identifier">LIBUSB_TRANSFER_FREE_TRANSFER</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Automatically call</span>
                                           <span class="Comment">## `libusb_free_transfer()` after callback returns. If this flag is set,</span>
                                           <span class="Comment">## it is illegal to call `libusb_free_transfer()` from your transfer</span>
                                           <span class="Comment">## callback, as this will result in a double-free when this flag is acted</span>
                                           <span class="Comment">## upon.</span>
  <span class="Identifier">LIBUSB_TRANSFER_ADD_ZERO_PACKET</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">3</span> <span class="Comment">## Terminate transfers that are \</span>
                                            <span class="Comment">## a multiple of the endpoint's wMaxPacketSize with an extra zero length</span>
                                            <span class="Comment">## packet. This is useful when a device protocol mandates that each</span>
                                            <span class="Comment">## logical request is terminated by an incomplete packet (i.e. the logical</span>
                                            <span class="Comment">## requests are not separated by other means).</span>
                                            <span class="Comment">##</span>
                                            <span class="Comment">## This flag only affects host-to-device transfers to bulk and interrupt</span>
                                            <span class="Comment">## endpoints. In other situations, it is ignored.</span>
                                            <span class="Comment">##</span>
                                            <span class="Comment">## This flag only affects transfers with a length that is a multiple of </span>
                                            <span class="Comment">## the endpoint's wMaxPacketSize. On transfers of other lengths, this flag</span>
                                            <span class="Comment">## has no effect. Therefore, if you are working with a device that needs a</span>
                                            <span class="Comment">## ZLP whenever the end of the logical request falls on a packet boundary,</span>
                                            <span class="Comment">## then it is sensible to set this flag on every transfer (you do not have</span>
                                            <span class="Comment">## to worry about only setting it on transfers that end on the boundary).</span>
                                            <span class="Comment">##</span>
                                            <span class="Comment">## This flag is currently only supported on Linux. On other systems,</span>
                                            <span class="Comment">## `libusb_submit_transfer()` will return `LIBUSB_ERROR_NOT_SUPPORTED`</span>
                                            <span class="Comment">## for every transfer where this flag is set.</span></pre></dt>
<dd>

Enumerates <cite>libusb_transfer.flags</cite> values.

</dd>
<dt id="libusb_iso_packet_descriptor"><a name="libusb_iso_packet_descriptor"></a><pre><span class="Identifier">libusb_iso_packet_descriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span>              <span class="Comment">## Length of data to request in this packet.</span>
  <span class="Identifier">actual_length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span>       <span class="Comment">## Amount of data that was actually transferred.</span>
  <span class="Identifier">status</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_status</span> <span class="Comment">## Status code for this packet.</span>
  </pre></dt>
<dd>
Isochronous packet descriptor.

</dd>
<dt id="libusb_transfer_cb_fn"><a name="libusb_transfer_cb_fn"></a><pre><span class="Identifier">libusb_transfer_cb_fn</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">fastcall</span><span class="Other">.}</span></pre></dt>
<dd>
Asynchronous transfer callback function type. When submitting asynchronous transfers, you pass a pointer to a callback function of this type via the <cite>libusb_transfer.callback</cite> member of the <cite>libusb_transfer</cite> object. libusb will call this function later, when the transfer has completed or failed.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The <cite>libusb_transfer</cite> object that the callback function 
         is being notified about</dd>
</dl>


</dd>
<dt id="libusb_transfer"><a name="libusb_transfer"></a><pre><span class="Identifier">libusb_transfer</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">dev_handle</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span> <span class="Comment">## Handle of the device that this</span>
                                        <span class="Comment">## transfer will be submitted to.</span>
  <span class="Identifier">flags</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>               <span class="Comment">## A bitwise OR combination of `libusb_transfer_flags`.</span>
  <span class="Identifier">endpoint</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuchar</span>           <span class="Comment">## Address of the endpoint where this transfer will be sent.</span>
  <span class="Other">`</span><span class="Keyword">type</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_type</span> <span class="Comment">## Type of the endpoint from `libusb_transfer_type`.</span>
  <span class="Identifier">timeout</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span> <span class="Comment">## Timeout for this transfer in millseconds. A value of 0</span>
                  <span class="Comment">## indicates no timeout.</span>
  <span class="Identifier">status</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_status</span> <span class="Comment">## The status of the transfer. Read-only,</span>
                                  <span class="Comment">## and only for use within transfer callback function.</span>
                                  <span class="Comment">##</span>
                                  <span class="Comment">## If this is an isochronous transfer, this field may read COMPLETED even</span>
                                  <span class="Comment">## if there were errors in the frames. Use the</span>
                                  <span class="Comment">## `libusb_iso_packet_descriptor.status` field in each packet to determine</span>
                                  <span class="Comment">## if errors occurred.</span>
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>               <span class="Comment">## Length of the data buffer.</span>
  <span class="Identifier">actual_length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Comment">## Actual length of data that was transferred.</span>
                       <span class="Comment">## Read-only, and only for use within transfer callback function.</span>
                       <span class="Comment">## Not valid for isochronous endpoint transfers.</span>
  <span class="Identifier">callback</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span> <span class="Comment">## Callback function. This will be invoked</span>
                                   <span class="Comment">## when the transfer completes, fails, or is cancelled.</span>
                                   <span class="Comment">## TODO: convert this to Nim</span>
  <span class="Identifier">user_data</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">pointer</span>         <span class="Comment">## User context data to pass to the callback function.</span>
  <span class="Identifier">buffer</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>            <span class="Comment">## Data buffer.</span>
  <span class="Identifier">num_iso_packets</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Comment">## Number of isochronous packets. Only used for I/O</span>
                         <span class="Comment">## with isochronous endpoints.</span>
  <span class="Identifier">iso_packet_desc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">libusb_iso_packet_descriptor_array</span> <span class="Comment">## Isochronous packet</span>
                                                       <span class="Comment">## descriptors, for isochronous transfers only.</span>
  </pre></dt>
<dd>
Generic USB transfer structure. The user populates this structure and then submits it in order to request a transfer. After the transfer has completed, the library populates the transfer with the results and passes it back to the user.

</dd>
<dt id="libusb_capability"><a name="libusb_capability"></a><pre><span class="Identifier">libusb_capability</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_CAP_HAS_CAPABILITY</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span> <span class="Comment">## The libusb_has_capability() API</span>
                                          <span class="Comment">## is available.</span>
  <span class="Identifier">LIBUSB_CAP_HAS_HOTPLUG</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## Hotplug support is available on this</span>
                                       <span class="Comment">## platform.</span>
  <span class="Identifier">LIBUSB_CAP_HAS_HID_ACCESS</span> <span class="Other">=</span> <span class="DecNumber">0x00000100</span><span class="Other">,</span> <span class="Comment">## The library can access HID</span>
                                          <span class="Comment">## devices without requiring user intervention. Note that before being</span>
                                          <span class="Comment">## able to actually access an HID device, you may still have to call</span>
                                          <span class="Comment">## additional libusb functions such as `libusb_detach_kernel_driver()`.</span>
  <span class="Identifier">LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER</span> <span class="Other">=</span> <span class="DecNumber">0x00000101</span> <span class="Comment">## The library</span>
                                                        <span class="Comment">## supports detaching of the default USB driver, using</span>
                                                        <span class="Comment">## `libusb_detach_kernel_driver()`, if one is set by the OS kernel.</span></pre></dt>
<dd>

Enumerates capabilities supported by an instance of libusb on the current running platform. Test if the loaded library supports a given capability by calling <cite>libusb_has_capability()</cite>.

</dd>
<dt id="libusb_log_level"><a name="libusb_log_level"></a><pre><span class="Identifier">libusb_log_level</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_LOG_LEVEL_NONE</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>  <span class="Comment">## No messages ever printed by the library (default)</span>
  <span class="Identifier">LIBUSB_LOG_LEVEL_ERROR</span><span class="Other">,</span>     <span class="Comment">## Error messages are printed to stderr</span>
  <span class="Identifier">LIBUSB_LOG_LEVEL_WARNING</span><span class="Other">,</span>   <span class="Comment">## Warning and error messages are printed to stderr</span>
  <span class="Identifier">LIBUSB_LOG_LEVEL_INFO</span><span class="Other">,</span>      <span class="Comment">## Informational messages are printed to stdout,</span>
                              <span class="Comment">## warning and error messages are printed to stderr</span>
  <span class="Identifier">LIBUSB_LOG_LEVEL_DEBUG</span>      <span class="Comment">## Debug and informational messages are printed to</span>
                              <span class="Comment">## stdout, warnings and errors to stderr</span></pre></dt>
<dd>

Enumerates log message levels.

</dd>
<dt id="libusb_pollfd"><a name="libusb_pollfd"></a><pre><span class="Identifier">libusb_pollfd</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">fd</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                   <span class="Comment">## Numeric file descriptor </span>
  <span class="Identifier">events</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cshort</span> <span class="Comment">## Event flags to poll for from &lt;poll.h&gt;. POLLIN indicates</span>
                  <span class="Comment">## that you should monitor this file descriptor for becoming ready to read</span>
                  <span class="Comment">## from, and POLLOUT indicates that you should monitor this file descriptor</span>
                  <span class="Comment">## for nonblocking write readiness. </span>
  </pre></dt>
<dd>
File descriptor for polling.

</dd>
<dt id="libusb_pollfd_added_cb"><a name="libusb_pollfd_added_cb"></a><pre><span class="Identifier">libusb_pollfd_added_cb</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">fd</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">events</span><span class="Other">:</span> <span class="Identifier">cshort</span><span class="Other">;</span> <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span></pre></dt>
<dd>


</dd>
<dt id="libusb_pollfd_removed_cb"><a name="libusb_pollfd_removed_cb"></a><pre><span class="Identifier">libusb_pollfd_removed_cb</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">fd</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span></pre></dt>
<dd>


</dd>
<dt id="libusb_hotplug_callback_handle"><a name="libusb_hotplug_callback_handle"></a><pre><span class="Identifier">libusb_hotplug_callback_handle</span> <span class="Other">=</span> <span class="Identifier">cint</span></pre></dt>
<dd>


</dd>
<dt id="libusb_hotplug_flag"><a name="libusb_hotplug_flag"></a><pre><span class="Identifier">libusb_hotplug_flag</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_HOTPLUG_NO_FLAGS</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Comment">## Default value when not using any flags.</span>
  <span class="Identifier">LIBUSB_HOTPLUG_ENUMERATE</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">0</span> <span class="Comment">## Arm the callback and fire it for all</span>
                                     <span class="Comment">## matching currently attached devices.</span></pre></dt>
<dd>

Enumerates flags for hotplug events.

</dd>
<dt id="libusb_hotplug_event"><a name="libusb_hotplug_event"></a><pre><span class="Identifier">libusb_hotplug_event</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## A device has been</span>
                                                    <span class="Comment">## plugged in and is ready to use.</span>
  <span class="Identifier">LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span> <span class="Comment">## A device has left and is no</span>
                                                <span class="Comment">## longer available. It is the user's responsibility to call `libusb_close`</span>
                                                <span class="Comment">## on any handle associated with a disconnected device. It is safe to call</span>
                                                <span class="Comment">## `libusb_get_device_descriptor` on a device that has left.</span></pre></dt>
<dd>

Enumerates hot plug events.

</dd>
<dt id="libusb_hotplug_callback_fn"><a name="libusb_hotplug_callback_fn"></a><pre><span class="Identifier">libusb_hotplug_callback_fn</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
                                   <span class="Identifier">device</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> 
                                   <span class="Identifier">event</span><span class="Other">:</span> <span class="Identifier">libusb_hotplug_event</span><span class="Other">;</span> 
                                   <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span></pre></dt>
<dd>


</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<dt id="LIBUSB_API_VERSION"><a name="LIBUSB_API_VERSION"></a><pre><span class="Identifier">LIBUSB_API_VERSION</span> <span class="Other">=</span> <span class="DecNumber">0x01000103</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_DEVICE_SIZE"><a name="LIBUSB_DT_DEVICE_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_DEVICE_SIZE</span> <span class="Other">=</span> <span class="DecNumber">18</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_CONFIG_SIZE"><a name="LIBUSB_DT_CONFIG_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_CONFIG_SIZE</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_INTERFACE_SIZE"><a name="LIBUSB_DT_INTERFACE_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_INTERFACE_SIZE</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_ENDPOINT_SIZE"><a name="LIBUSB_DT_ENDPOINT_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_ENDPOINT_SIZE</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_ENDPOINT_AUDIO_SIZE"><a name="LIBUSB_DT_ENDPOINT_AUDIO_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_ENDPOINT_AUDIO_SIZE</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_HUB_NONVAR_SIZE"><a name="LIBUSB_DT_HUB_NONVAR_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_HUB_NONVAR_SIZE</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE"><a name="LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE</span> <span class="Other">=</span> <span class="DecNumber">6</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_BOS_SIZE"><a name="LIBUSB_DT_BOS_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_BOS_SIZE</span> <span class="Other">=</span> <span class="DecNumber">5</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_DEVICE_CAPABILITY_SIZE"><a name="LIBUSB_DT_DEVICE_CAPABILITY_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_DEVICE_CAPABILITY_SIZE</span> <span class="Other">=</span> <span class="DecNumber">3</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_BT_USB_2_0_EXTENSION_SIZE"><a name="LIBUSB_BT_USB_2_0_EXTENSION_SIZE"></a><pre><span class="Identifier">LIBUSB_BT_USB_2_0_EXTENSION_SIZE</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE"><a name="LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE"></a><pre><span class="Identifier">LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE</span> <span class="Other">=</span> <span class="DecNumber">10</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_BT_CONTAINER_ID_SIZE"><a name="LIBUSB_BT_CONTAINER_ID_SIZE"></a><pre><span class="Identifier">LIBUSB_BT_CONTAINER_ID_SIZE</span> <span class="Other">=</span> <span class="DecNumber">20</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_DT_BOS_MAX_SIZE"><a name="LIBUSB_DT_BOS_MAX_SIZE"></a><pre><span class="Identifier">LIBUSB_DT_BOS_MAX_SIZE</span> <span class="Other">=</span> <span class="DecNumber">42</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_ENDPOINT_ADDRESS_MASK"><a name="LIBUSB_ENDPOINT_ADDRESS_MASK"></a><pre><span class="Identifier">LIBUSB_ENDPOINT_ADDRESS_MASK</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_ENDPOINT_DIR_MASK"><a name="LIBUSB_ENDPOINT_DIR_MASK"></a><pre><span class="Identifier">LIBUSB_ENDPOINT_DIR_MASK</span> <span class="Other">=</span> <span class="DecNumber">0x00000080</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_TRANSFER_TYPE_MASK"><a name="LIBUSB_TRANSFER_TYPE_MASK"></a><pre><span class="Identifier">LIBUSB_TRANSFER_TYPE_MASK</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span></pre></dt>
<dd>
in bmAttributes

</dd>
<dt id="LIBUSB_ISO_SYNC_TYPE_MASK"><a name="LIBUSB_ISO_SYNC_TYPE_MASK"></a><pre><span class="Identifier">LIBUSB_ISO_SYNC_TYPE_MASK</span> <span class="Other">=</span> <span class="DecNumber">0x0000000C</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_ISO_USAGE_TYPE_MASK"><a name="LIBUSB_ISO_USAGE_TYPE_MASK"></a><pre><span class="Identifier">LIBUSB_ISO_USAGE_TYPE_MASK</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span></pre></dt>
<dd>


</dd>
<dt id="LIBUSB_ERROR_COUNT"><a name="LIBUSB_ERROR_COUNT"></a><pre><span class="Identifier">LIBUSB_ERROR_COUNT</span> <span class="Other">=</span> <span class="DecNumber">14</span></pre></dt>
<dd>
Total number of error codes in enum libusb_error.

</dd>
<dt id="LIBUSB_HOTPLUG_MATCH_ANY"><a name="LIBUSB_HOTPLUG_MATCH_ANY"></a><pre><span class="Identifier">LIBUSB_HOTPLUG_MATCH_ANY</span> <span class="Other">=</span> <span class="DecNumber">-1</span></pre></dt>
<dd>
Wildcard matching for hotplug events.

</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="libusb_cpu_to_le16"><a name="libusb_cpu_to_le16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_cpu_to_le16</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Converts a 16-bit value from host-endian to little-endian format.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">x</span></tt> - The value to convert.</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd>The converted value.</dd>
</dl>


</dd>
<dt id="libusb_init"><a name="libusb_init,ptr.ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_init</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_init&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initializes libusb.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">context</span></tt> - Optional output location for context pointer. 
           Only valid on return code 0</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> code on failure</li>
</ul>
</dd>
</dl>
<p>This function must be called before calling any other libusb function. If you do not provide an output location for a context pointer, a default context will be created. If there was already a default context, it will be reused (and nothing will be initialized/reinitialized).</p>


</dd>
<dt id="libusb_exit"><a name="libusb_exit,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_exit</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_exit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Shuts down libusb.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to deinitialize, or nil for the default context.</dd>
</dl>
<p>Should be called after closing all open devices and before your application terminates.</p>


</dd>
<dt id="libusb_set_debug"><a name="libusb_set_debug,ptr.libusb_context,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_debug</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">level</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_debug&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Sets the log message verbosity.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context <tt class="docutils literal"><span class="pre">level</span></tt> - The debug level to set</dd>
</dl>
<p>The default level is LIBUSB_LOG_LEVEL_NONE, which means no messages are ever printed. If you choose to increase the message verbosity level, ensure that your application does not close the stdout/stderr file descriptors.</p>
<p>You are advised to use level LIBUSB_LOG_LEVEL_WARNING. libusb is conservative with its message logging and most of the time, will only log messages that explain error conditions and other oddities. This will help you debug your software.</p>
<p>If the LIBUSB_DEBUG environment variable was set when libusb was initialized, this function does nothing: the message verbosity is fixed to the value in the environment variable.</p>
<p>If libusb was compiled without any message logging, this function does nothing: you'll never get any messages. If libusb was compiled with verbose debug message logging, this function does nothing: you'll always get messages from all levels.</p>


</dd>
<dt id="libusb_get_version"><a name="libusb_get_version,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_version</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_version</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_version&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
<p>Gets the version (major, minor, micro, nano and rc) of the running library.</p>
<p><tt class="docutils literal"><span class="pre">Returns</span></tt> an object containing the version number.</p>


</dd>
<dt id="libusb_has_capability"><a name="libusb_has_capability,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_has_capability</span><span class="Other">(</span><span class="Identifier">capability</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_has_capability&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Checks at runtime if the loaded library has a given capability.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">capability</span></tt> - The libusb_capability to check for</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>nonzero if the running library has the capability</li>
<li>0 otherwise.</li>
</ul>
</dd>
</dl>
<p>This call should be performed after <cite>libusb_init()</cite>, to ensure the backend has updated its capability set.</p>


</dd>
<dt id="libusb_error_name"><a name="libusb_error_name,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_error_name</span><span class="Other">(</span><span class="Identifier">errcode</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_error_name&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a constant nil-terminated string with the ASCII name of a libusb error or transfer status code.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">error_code</span></tt> - The libusb_error or libusb_transfer_status code to 
           return the name of</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the error name if <cite>errcode</cite> is known</li>
<li><cite>UNKNOWN</cite> if the value of <cite>error_code</cite> is not a known code</li>
</ul>
</dd>
</dl>
<p>The caller must not free the returned string.</p>


</dd>
<dt id="libusb_setlocale"><a name="libusb_setlocale,cstring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_setlocale</span><span class="Other">(</span><span class="Identifier">locale</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_setlocale&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Sets the language, and only the language, not the encoding! used for translatable libusb messages.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">locale</span></tt> - The locale-string in the form of 
           lang[_country_region][.codeset] or lang[-region], where lang 
           is a 2 letter ISO 639-1 code.</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li><cite>LIBUSB_SUCCESS</cite> on success</li>
<li><cite>LIBUSB_ERROR_INVALID_PARAM</cite> if the locale doesn't meet the requirements</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the requested language is not supported</li>
<li><cite>LIBUSB_ERROR</cite> code on other errors.</li>
</ul>
</dd>
</dl>
<p>This takes a locale string in the default setlocale format: lang[-region] or lang[_country_region][.codeset]. Only the lang part of the string is used, and only 2 letter ISO 639-1 codes are accepted for it, such as &quot;de&quot;. The optional region, country_region or codeset parts are ignored. This means that functions which return translatable strings will NOT honor the specified encoding. All strings returned are encoded as UTF-8 strings.</p>
<p>If <cite>libusb_setlocale()</cite> is not called, all messages will be in English. The following functions return translatable strings:</p>
<blockquote><p><ul class="simple"><li><cite>libusb_strerror()</cite></li>
</ul>
</p></blockquote>
<p>Note that the libusb log messages controlled through <cite>libusb_set_debug()</cite> are not translated, they are always in English.</p>
<p>For POSIX UTF-8 environments if you want libusb to follow the standard locale settings, call libusb_setlocale(setlocale(LC_MESSAGES, nil)), after your app has done its locale setup.</p>


</dd>
<dt id="libusb_strerror"><a name="libusb_strerror,libusb_error"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_strerror</span><span class="Other">(</span><span class="Identifier">errcode</span><span class="Other">:</span> <span class="Identifier">libusb_error</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_strerror&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a constant string with a short description of the given error code.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">errcode</span></tt> - The error code whose description is desired</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>a short description of the error code in UTF-8 encoding.</li>
</ul>
</dd>
</dl>
<p>This description is intended for displaying to the end user and will be in the language set by <cite>libusb_setlocale()</cite>. The returned string is encoded in UTF-8. The messages always start with a capital letter and end without any dot. The caller must not free the returned string.</p>


</dd>
<dt id="libusb_get_device_list"><a name="libusb_get_device_list,ptr.libusb_context,ptr.ptr.libusb_device_array"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_device_list</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
                            <span class="Identifier">list</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_array</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">csize</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_list&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a list of USB devices currently attached to the system.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">list</span></tt> - The output location for a list of devices. Must be later 
           freed with <cite>libusb_free_device_list()</cite></p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the number of devices in the outputted list, or</li>
<li>any <cite>libusb_error</cite> according to errors encountered by the backend</li>
</ul>
</dd>
</dl>
<p>This is your entry point into finding a USB device to operate. You are expected to unreference all the devices when you are done with them, and then free the list with <cite>libusb_free_device_list()</cite>.</p>
<p>Note that <cite>libusb_free_device_list()</cite> can unref all the devices for you. Be careful not to unreference a device you are about to open until after you have opened it.</p>
<p>The return value of this function indicates the number of devices in the resultant list. The list is actually one element larger, as it is nil-terminated.</p>


</dd>
<dt id="libusb_free_device_list"><a name="libusb_free_device_list,ptr.libusb_device_array,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_device_list</span><span class="Other">(</span><span class="Identifier">list</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_array</span><span class="Other">;</span> <span class="Identifier">unref_devices</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_device_list&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a list of devices previously discovered using <cite>libusb_get_device_list()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">list</span></tt> - The list to free <tt class="docutils literal"><span class="pre">unref_devices</span></tt> - Whether to unref the devices in the list</dd>
</dl>
<p>If the <cite>unref_devices parameter</cite> is set, the reference count of each device in the list is decremented by 1.</p>


</dd>
<dt id="libusb_ref_device"><a name="libusb_ref_device,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_ref_device</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_ref_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Increments the reference count of a device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - The device to reference</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the same device</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_unref_device"><a name="libusb_unref_device,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_unref_device</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unref_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Decrement the reference count of a device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - The device to unreference</dd>
</dl>
<p>If the decrement operation causes the reference count to reach zero, the device shall be destroyed.</p>


</dd>
<dt id="libusb_get_configuration"><a name="libusb_get_configuration,ptr.libusb_device_handle,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_configuration</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_configuration&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determines the bConfigurationValue of the currently active configuration.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - Output location for the bConfigurationValue of the active 
           configuration (only valid for return code 0)</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes for other failures</li>
</ul>
</dd>
</dl>
<p>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information. This function will return a value of 0 in the config output parameter if the device is in unconfigured state.</p>


</dd>
<dt id="libusb_get_device_descriptor"><a name="libusb_get_device_descriptor,ptr.libusb_device,ptr.libusb_device_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_device_descriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> 
                                  <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets the USB device descriptor for a given device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - The device <tt class="docutils literal"><span class="pre">desc</span></tt> - Output location for the descriptor data</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> code on failure</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function; the device descriptor is cached in memory. Note since libusb-1.0.16, <cite>LIBUSB_API_VERSION</cite> &gt;= 0x01000102, this function always succeeds.</p>


</dd>
<dt id="libusb_get_active_config_descriptor"><a name="libusb_get_active_config_descriptor,ptr.libusb_device,ptr.ptr.libusb_config_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_active_config_descriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> 
    <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_config_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_active_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets the USB configuration descriptor for the currently active configuration.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - Output location for the USB configuration descriptor. 
           Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_config_descriptor()</cite> after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the device is in unconfigured state</li>
<li><cite>LIBUSB_ERROR</cite> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>


</dd>
<dt id="libusb_get_config_descriptor"><a name="libusb_get_config_descriptor,ptr.libusb_device,uint8,ptr.ptr.libusb_config_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_config_descriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> <span class="Identifier">config_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                                  <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_config_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a USB configuration descriptor based on its index.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device <tt class="docutils literal"><span class="pre">config_index</span></tt> - The index of the configuration you wish to retrieve</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - Output location for the USB configuration descriptor. 
           Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_config_descriptor()</cite> after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the configuration does not exist</li>
<li><cite>LIBUSB_ERROR</cite> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>


</dd>
<dt id="libusb_get_config_descriptor_by_value"><a name="libusb_get_config_descriptor_by_value,ptr.libusb_device,uint8,ptr.ptr.libusb_config_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_config_descriptor_by_value</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> 
    <span class="Identifier">bConfigurationValue</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_config_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_config_descriptor_by_value&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a USB configuration descriptor with a specific bConfigurationValue.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</p>
<p><tt class="docutils literal"><span class="pre">bConfigurationValue</span></tt> - The <cite>bConfigurationValue</cite> of the 
           configuration you wish to retrieve</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - Output location for the USB configuration descriptor. 
           Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_config_descriptor()</cite> after use</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the configuration does not exist</li>
<li><cite>LIBUSB_ERROR</cite> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>


</dd>
<dt id="libusb_free_config_descriptor"><a name="libusb_free_config_descriptor,ptr.libusb_config_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_config_descriptor</span><span class="Other">(</span><span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_config_descriptor</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a configuration descriptor obtained from <cite>libusb_get_active_config_descriptor() or `libusb_get_config_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">config</span></tt> - The configuration descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil config parameter, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_ss_endpoint_companion_descriptor"><a name="libusb_get_ss_endpoint_companion_descriptor,ptr.libusb_context,ptr.libusb_endpoint_descriptor,ptr.ptr.libusb_ss_endpoint_companion_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_ss_endpoint_companion_descriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
    <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_endpoint_descriptor</span><span class="Other">;</span> 
    <span class="Identifier">ep_comp</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_ss_endpoint_companion_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_ss_endpoint_companion_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets an endpoints superspeed endpoint companion descriptor (if any).<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context.</p>
<p><tt class="docutils literal"><span class="pre">endpoint</span></tt> - Endpoint descriptor from which to get the superspeed 
           endpoint companion descriptor.</p>
<p><tt class="docutils literal"><span class="pre">ep_comp</span></tt> - Output location for the superspeed endpoint companion 
           descriptor. Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_ss_endpoint_companion_descriptor()</cite> after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the configuration does not exist</li>
<li><cite>LIBUSB_ERROR</cite> codes for other errors</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_free_ss_endpoint_companion_descriptor"><a name="libusb_free_ss_endpoint_companion_descriptor,ptr.libusb_ss_endpoint_companion_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_ss_endpoint_companion_descriptor</span><span class="Other">(</span>
    <span class="Identifier">ep_comp</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_ss_endpoint_companion_descriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_ss_endpoint_companion_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free a superspeed endpoint companion descriptor obtained from <cite>libusb_get_ss_endpoint_companion_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ep_comp</span></tt> - The superspeed endpoint companion descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil <cite>ep_comp parameter</cite>, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_bos_descriptor"><a name="libusb_get_bos_descriptor,ptr.libusb_device_handle,ptr.ptr.libusb_bos_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_bos_descriptor</span><span class="Other">(</span><span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                               <span class="Identifier">bos</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_bos_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a Binary Object Store (BOS) descriptor This is a BLOCKING function, which will send requests to the device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">handle</span></tt> - The handle of an open libusb device</p>
<p><tt class="docutils literal"><span class="pre">bos</span></tt> - Output location for the BOS descriptor. Only valid if 0 was 
           returned. Must be freed with <cite>libusb_free_bos_descriptor()</cite> 
           after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the device doesn't have a BOS descriptor</li>
<li><cite>LIBUSB_ERROR</cite> codes for other errors</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_free_bos_descriptor"><a name="libusb_free_bos_descriptor,ptr.libusb_bos_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_bos_descriptor</span><span class="Other">(</span><span class="Identifier">bos</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_descriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_bos_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a BOS descriptor obtained from <cite>libusb_get_bos_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">bos</span></tt> - The BOS descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil bos parameter, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_usb_2_0_extension_descriptor"><a name="libusb_get_usb_2_0_extension_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_usb_2_0_extension_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_usb_2_0_extension_descriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
    <span class="Identifier">dev_cap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_dev_capability_descriptor</span><span class="Other">;</span> 
    <span class="Identifier">usb_2_0_extension</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_usb_2_0_extension_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_usb_2_0_extension_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets an USB 2.0 Extension descriptor.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">dev_cap</span></tt> - Device Capability descriptor with a bDevCapabilityType 
           of <cite>libusb_capability_type.LIBUSB_BT_USB_2_0_EXTENSION</cite></p>
<p><tt class="docutils literal"><span class="pre">usb_2_0_extension</span></tt> - Output location for the USB 2.0 Extension 
           descriptor. Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_usb_2_0_extension_descriptor()</cite> after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> code on error</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_free_usb_2_0_extension_descriptor"><a name="libusb_free_usb_2_0_extension_descriptor,ptr.libusb_usb_2_0_extension_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_usb_2_0_extension_descriptor</span><span class="Other">(</span>
    <span class="Identifier">usb_2_0_extension</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_usb_2_0_extension_descriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_usb_2_0_extension_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a USB 2.0 Extension descriptor obtained from <cite>libusb_get_usb_2_0_extension_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">usb_2_0_extension</span></tt> - The USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil <cite>usb_2_0_extension</cite> parameter, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_ss_usb_device_capability_descriptor"><a name="libusb_get_ss_usb_device_capability_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_ss_usb_device_capability_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_ss_usb_device_capability_descriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
    <span class="Identifier">dev_cap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_dev_capability_descriptor</span><span class="Other">;</span> 
    <span class="Identifier">ss_usb_device_cap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_ss_usb_device_capability_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_ss_usb_device_capability_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a SuperSpeed USB Device Capability descriptor.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">dev_cap</span></tt> - Device Capability descriptor with a <cite>bDevCapabilityType</cite> 
           of <cite>LIBUSB_BT_SS_USB_DEVICE_CAPABILITY</cite></p>
<p><tt class="docutils literal"><span class="pre">ss_usb_device_cap</span></tt> - Output location for the SuperSpeed USB Device 
           Capability descriptor. Only valid if 0 was returned. Must be 
           freed with <cite>libusb_free_ss_usb_device_capability_descriptor()</cite> 
           after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li>LIBUSB_ERROR code on error</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_free_ss_usb_device_capability_descriptor"><a name="libusb_free_ss_usb_device_capability_descriptor,ptr.libusb_ss_usb_device_capability_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_ss_usb_device_capability_descriptor</span><span class="Other">(</span>
    <span class="Identifier">ss_usb_device_cap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_ss_usb_device_capability_descriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_ss_usb_device_capability_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a SuperSpeed USB Device Capability descriptor obtained from <cite>libusb_get_ss_usb_device_capability_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ss_usb_device_cap</span></tt> - the USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil <cite>ss_usb_device_cap parameter</cite>, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_container_id_descriptor"><a name="libusb_get_container_id_descriptor,ptr.libusb_context,ptr.libusb_bos_dev_capability_descriptor,ptr.ptr.libusb_container_id_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_container_id_descriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">dev_cap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_bos_dev_capability_descriptor</span><span class="Other">;</span> 
    <span class="Identifier">container_id</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_container_id_descriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_container_id_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a Container ID descriptor.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">dev_cap</span></tt> - Device Capability descriptor with a <cite>bDevCapabilityType</cite> 
           of <cite>libusb_capability_type.LIBUSB_BT_CONTAINER_ID</cite></p>
<p><tt class="docutils literal"><span class="pre">container_id</span></tt> - Output location for the Container ID descriptor. 
           Only valid if 0 was returned. Must be freed with 
           <cite>libusb_free_container_id_descriptor()</cite> after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> code on error</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_free_container_id_descriptor"><a name="libusb_free_container_id_descriptor,ptr.libusb_container_id_descriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_container_id_descriptor</span><span class="Other">(</span>
    <span class="Identifier">container_id</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_container_id_descriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_container_id_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a Container ID descriptor obtained from <cite>libusb_get_container_id_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">container_id</span></tt> - The USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a nil <cite>container_id</cite> parameter, in which case the function simply returns.</p>


</dd>
<dt id="libusb_get_bus_number"><a name="libusb_get_bus_number,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_bus_number</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_bus_number&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets the number of the bus that a device is connected to.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the bus number</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_get_port_number"><a name="libusb_get_port_number,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_port_number</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_port_number&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the number of the port that a device is connected to.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the port number (0 if not available)</li>
</ul>
</dd>
</dl>
<p>Unless the OS does something funky, or you are hot-plugging USB extension cards, the port number returned by this call is usually guaranteed to be uniquely tied to a physical port, meaning that different devices plugged on the same physical port should return the same port number.</p>
<p>But outside of this, there is no guarantee that the port number returned by this call will remain the same, or even match the order in which ports have been numbered by the HUB/HCD manufacturer.</p>


</dd>
<dt id="libusb_get_port_numbers"><a name="libusb_get_port_numbers,ptr.libusb_device,ptr.uint8,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_port_numbers</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> <span class="Identifier">port_numbers</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                             <span class="Identifier">port_numbers_len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_port_numbers&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the list of all port numbers from root for the specified device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device <tt class="docutils literal"><span class="pre">port_numbers</span></tt> - The array that should contain the port numbers</p>
<p><tt class="docutils literal"><span class="pre">port_numbers_len</span></tt> - The maximum length of the array. As per the 
           USB 3.0 specs, the current maximum limit for the depth is 7</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the number of elements filled</li>
<li><cite>LIBUSB_ERROR_OVERFLOW</cite> if the array is too small.</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_get_parent"><a name="libusb_get_parent,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_parent</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_parent&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the the parent from the specified device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the device parent</li>
<li>nil if not available</li>
</ul>
</dd>
</dl>
<p>You should issue a <cite>libusb_get_device_list()</cite> before calling this function and make sure that you only access the parent before issuing <cite>libusb_free_device_list()</cite>. The reason is that libusb currently does not maintain a permanent list of device instances, and therefore can only guarantee that parents are fully instantiated within a <cite>libusb_get_device_list()</cite> - <cite>libusb_free_device_list()</cite> block.</p>


</dd>
<dt id="libusb_get_device_address"><a name="libusb_get_device_address,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_device_address</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_address&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the address of the device on the bus it is connected to.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the device address</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_get_device_speed"><a name="libusb_get_device_speed,ptr.libusb_device"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_device_speed</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_speed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the negotiated connection speed for a device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li><cite>libusb_speed code</cite>, where <cite>LIBUSB_SPEED_UNKNOWN</cite> means that the OS 
           doesn't know or doesn't support returning the negotiated speed.</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_get_max_packet_size"><a name="libusb_get_max_packet_size,ptr.libusb_device,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_max_packet_size</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_max_packet_size&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active device configuration.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device <tt class="docutils literal"><span class="pre">endpoint</span></tt> - Address of the endpoint in question</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the wMaxPacketSize value</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the endpoint does not exist</li>
<li><cite>LIBUSB_ERROR_OTHER</cite> on other failure  ##</li>
</ul>
</dd>
</dl>
<p>This function was originally intended to be of assistance when setting up isochronous transfers, but a design mistake resulted in this function instead. It simply returns the wMaxPacketSize value without considering its contents. If you're dealing with isochronous transfers, you probably want <cite>libusb_get_max_iso_packet_size()</cite> instead.</p>


</dd>
<dt id="libusb_get_max_iso_packet_size"><a name="libusb_get_max_iso_packet_size,ptr.libusb_device,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_max_iso_packet_size</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_max_iso_packet_size&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device <tt class="docutils literal"><span class="pre">endpoint</span></tt> - Address of the endpoint in question</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the maximum packet size which can be sent/received on this endpoint</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the endpoint does not exist</li>
<li><cite>LIBUSB_ERROR_OTHER</cite> on other failure</li>
</ul>
</dd>
</dl>
<p>Only the active configuration is examined. The calculation is based on the <cite>wMaxPacketSize</cite> field in the endpoint descriptor as described in section 9.6.6 in the USB 2.0 specifications.</p>
<p>If acting on an isochronous or interrupt endpoint, this function will multiply the value found in bits 0:10 by the number of transactions per microframe (determined by bits 11:12). Otherwise, this function just returns the numeric value found in bits 0:10.</p>
<p>This function is useful for setting up isochronous transfers, for example you might pass the return value from this function to <cite>libusb_set_iso_packet_lengths()</cite> in order to set the length field of every isochronous packet in a transfer.</p>


</dd>
<dt id="libusb_open"><a name="libusb_open,ptr.libusb_device,ptr.ptr.libusb_device_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_open</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span><span class="Other">;</span> <span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_open&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Open a device and obtain a device handle.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - The device to open</p>
<p><tt class="docutils literal"><span class="pre">handle</span></tt> - Output location for the returned device handle pointer. 
           Only populated when the return code is 0</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NO_MEM</cite> on memory allocation failure</li>
<li><cite>LIBUSB_ERROR_ACCESS</cite> if the user has insufficient permissions</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>A handle allows you to perform I/O on the device in question. Internally, this function adds a reference to the device and makes it available to you through <cite>libusb_get_device()</cite>. This reference is removed during <cite>libusb_close()</cite>.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>


</dd>
<dt id="libusb_close"><a name="libusb_close,ptr.libusb_device_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_close</span><span class="Other">(</span><span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_close&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Close a device handle.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev_handle</span></tt>- The handle to close</dd>
</dl>
<p>Should be called on all open handles before your application exits. Internally, this function destroys the reference that was added by <cite>libusb_open()</cite> on the given device. This is a non-blocking function; no requests are sent over the bus.</p>


</dd>
<dt id="libusb_get_device"><a name="libusb_get_device,ptr.libusb_device_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_device</span><span class="Other">(</span><span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the underlying device for a handle.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev_handle</span></tt> - A device handle</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the underlying device</li>
</ul>
</dd>
</dl>
<p>This function does not modify the reference count of the returned device, so do not feel compelled to unreference it when you are done.</p>


</dd>
<dt id="libusb_set_configuration"><a name="libusb_set_configuration,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_configuration</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">configuration</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_configuration&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine the bConfigurationValue of the currently active configuration.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle</p>
<p><tt class="docutils literal"><span class="pre">config</span></tt> - Output location for the bConfigurationValue of the active 
           configuration (only valid for return code 0).</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information. This function will return a value of 0 in the config output parameter if the device is in unconfigured state.</p>


</dd>
<dt id="libusb_claim_interface"><a name="libusb_claim_interface,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_claim_interface</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                            <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_claim_interface&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Claim an interface on a given device handle.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle</p>
<p><tt class="docutils literal"><span class="pre">interface_number</span></tt> - The bInterfaceNumber of the interface you wish 
           to claim</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the requested interface does not exist</li>
<li><cite>LIBUSB_ERROR_BUSY</cite> if another program or driver has claimed the 
           interface</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codeS on other failures.</li>
</ul>
</dd>
</dl>
<p>You must claim the interface you wish to use before you can perform I/O on any of its endpoints. It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</p>
<p>If <cite>auto_detach_kernel_driver</cite> is set to 1 for dev, the kernel driver will be detached if necessary, on failure the detach error is returned. Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</p>
<p>This is a non-blocking function.</p>


</dd>
<dt id="libusb_release_interface"><a name="libusb_release_interface,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_release_interface</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                              <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_release_interface&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release an interface previously claimed with <cite>libusb_claim_interface()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle</p>
<p><tt class="docutils literal"><span class="pre">interface_number</span></tt> - The bInterfaceNumber of the previously-claimed 
           interface</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the interface was not claimed</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>You should release all claimed interfaces before closing a device handle. This is a blocking function. A <cite>SET_INTERFACE</cite> control request will be sent to the device, resetting interface state to the first alternate setting.</p>
<p>If <cite>auto_detach_kernel_driver</cite> is set to 1 for dev, the kernel driver will be re-attached after releasing the interface.</p>


</dd>
<dt id="libusb_open_device_with_vid_pid"><a name="libusb_open_device_with_vid_pid,ptr.libusb_context,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_open_device_with_vid_pid</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">vendor_id</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                                     <span class="Identifier">product_id</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_open_device_with_vid_pid&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function for finding a device with a particular idVendor / idProduct combination.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or NULL for the default context <tt class="docutils literal"><span class="pre">vendor_id</span></tt> - The idVendor value to search for <tt class="docutils literal"><span class="pre">product_id</span></tt> - The idProduct value to search for</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>a handle for the first found device</li>
<li>nil on error or if the device could not be found.</li>
</ul>
</dd>
</dl>
<p>This function is intended for those scenarios where you are using libusb to knock up a quick test application - it allows you to avoid calling <cite>libusb_get_device_list()</cite> and worrying about traversing/freeing the list. This function has limitations and is hence not intended for use in real applications: if multiple devices have the same IDs it will only give you the first one, etc.</p>


</dd>
<dt id="libusb_set_interface_alt_setting"><a name="libusb_set_interface_alt_setting,ptr.libusb_device_handle,cint,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_interface_alt_setting</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                      <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                      <span class="Identifier">alternate_setting</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_interface_alt_setting&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Activate an alternate setting for an interface.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle</p>
<p><tt class="docutils literal"><span class="pre">interface_number</span></tt> - The <cite>bInterfaceNumber</cite> of the 
           previously-claimed interface</p>
<p><tt class="docutils literal"><span class="pre">alternate_setting</span></tt> - The <cite>bAlternateSetting</cite> of the alternate 
           setting to activate</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the interface was not claimed, or the 
           requested alternate setting does not exist</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The interface must have been previously claimed with <cite>libusb_claim_interface()</cite>. You should always use this function rather than formulating your own <cite>SET_INTERFACE</cite> control request. This is because the underlying operating system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>


</dd>
<dt id="libusb_clear_halt"><a name="libusb_clear_halt,ptr.libusb_device_handle,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_clear_halt</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_clear_halt&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Clear the halt/stall condition for an endpoint.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">endpoint</span></tt> - The endpoint to clear halt status</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the endpoint does not exist</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> code on other failure</li>
</ul>
</dd>
</dl>
<p>Endpoints with halt status are unable to receive or transmit data until the halt condition is stalled. You should cancel all pending transfers before attempting to clear the halt condition.</p>
<p>This is a blocking function.</p>


</dd>
<dt id="libusb_reset_device"><a name="libusb_reset_device,ptr.libusb_device_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_reset_device</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_reset_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB port reset to reinitialize a device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A handle of the device to reset</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if re-enumeration is required, or if the 
           device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The system will attempt to restore the previous configuration and alternate settings after the reset has completed. If the reset fails, the descriptors change, or the previous state cannot be restored, the device will appear to be disconnected and reconnected. This means that the device handle is no longer valid (you should close it) and rediscover the device. A return code of LIBUSB_ERROR_NOT_FOUND indicates when this is the case.</p>
<p>This is a blocking function which usually incurs a noticeable delay.</p>


</dd>
<dt id="libusb_alloc_streams"><a name="libusb_alloc_streams,ptr.libusb_device_handle,uint32,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_alloc_streams</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">num_streams</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> 
                          <span class="Identifier">endpoints</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">num_endpoints</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_alloc_streams&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate up to num_streams usb bulk streams on the specified endpoints.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">num_streams</span></tt> - Number of streams to try to allocate <tt class="docutils literal"><span class="pre">endpoints</span></tt> - Array of endpoints to allocate streams on <tt class="docutils literal"><span class="pre">num_endpoints</span></tt> - Length of the endpoints array</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>number of streams allocated</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>This function takes an array of endpoints rather then a single endpoint because some protocols require that endpoints are setup with similar stream ids. All endpoints passed in must belong to the same interface.</p>
<p>Note this function may return less streams then requested. Also note that the same number of streams are allocated for each endpoint in the endpoint array. Stream id 0 is reserved, and should not be used to communicate with devices. If libusb_alloc_streams() returns with a value of N, you may use stream ids 1 to N.</p>


</dd>
<dt id="libusb_free_streams"><a name="libusb_free_streams,ptr.libusb_device_handle,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_streams</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">endpoints</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                         <span class="Identifier">num_endpoints</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_streams&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free usb bulk streams allocated with <cite>libusb_alloc_streams()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">endpoints</span></tt> - Array of endpoints to free streams on <tt class="docutils literal"><span class="pre">num_endpoints</span></tt> - Length of the endpoints array</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li><cite>LIBUSB_SUCCESS</cite> on success</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>Note streams are automatically free-ed when releasing an interface.</p>


</dd>
<dt id="libusb_kernel_driver_active"><a name="libusb_kernel_driver_active,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_kernel_driver_active</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                 <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_kernel_driver_active&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if a kernel driver is active on an interface.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">interface_number</span></tt> - The interface to check</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 if no kernel driver is active</li>
<li>1 if a kernel driver is active</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> on platforms where the functionality is 
           not available</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O. This functionality is not available on Windows.</p>


</dd>
<dt id="libusb_detach_kernel_driver"><a name="libusb_detach_kernel_driver,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_detach_kernel_driver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                 <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_detach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Detach a kernel driver from an interface.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">interface_number</span></tt> - The interface to detach the driver from</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if no kernel driver was active</li>
<li><cite>LIBUSB_ERROR_INVALID_PARAM</cite> if the interface does not exist</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> on platforms where the functionality is 
           not available,</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>If successful, you will then be able to claim the interface and perform I/O. This functionality is not available on Darwin or Windows. Note that libusb itself also talks to the device through a special kernel driver, if this driver is already attached to the device, this call will not detach it and return <cite>LIBUSB_ERROR_NOT_FOUND</cite>.</p>


</dd>
<dt id="libusb_attach_kernel_driver"><a name="libusb_attach_kernel_driver,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_attach_kernel_driver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                 <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_attach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Re-attach an interface's kernel driver, which was previously detached using <cite>libusb_detach_kernel_driver()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">interface_number</span></tt> - The interface to attach the driver from</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if no kernel driver was active</li>
<li><cite>LIBUSB_ERROR_INVALID_PARAM</cite> if the interface does not exist</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> on platforms where the functionality is 
           not available</li>
<li><cite>LIBUSB_ERROR_BUSY</cite> if the driver cannot be attached because the 
           interface is claimed by a program or driver</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>This call is only effective on Linux and returns <cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> on all other platforms. This functionality is not available on Darwin or Windows.</p>


</dd>
<dt id="libusb_set_auto_detach_kernel_driver"><a name="libusb_set_auto_detach_kernel_driver,ptr.libusb_device_handle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_auto_detach_kernel_driver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
    <span class="Identifier">enable</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
                          <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_auto_detach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
<p>Enable/disable libusb's automatic kernel driver detachment.</p>
<p>When this is enabled libusb will automatically detach the kernel driver on an interface when claiming the interface, and attach it when releasing the interface. Automatic kernel driver detachment is disabled on newly opened device handles by default.</p>
<p>On platforms which do not have <cite>LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER</cite> this function will return <cite>LIBUSB_ERROR_NOT_SUPPORTED</cite>, and libusb will continue as if this function was never called.</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">enable</span></tt> - Whether to enable or disable auto kernel driver detachment</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li><cite>LIBUSB_SUCCESS</cite> on success</li>
<li><cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> on platforms where the functionality is 
           not available.</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_control_transfer_get_data"><a name="libusb_control_transfer_get_data,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_control_transfer_get_data</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Get the data section of a control transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - A transfer</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>pointer to the first byte of the data section</li>
</ul>
</dd>
</dl>
<p>This convenience function is here to remind you that the data does not start until 8 bytes into the actual buffer, as the setup packet comes first. Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</p>


</dd>
<dt id="libusb_control_transfer_get_setup"><a name="libusb_control_transfer_get_setup,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_control_transfer_get_setup</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_control_setup</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Get the control setup packet of a control transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - A transfer</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>a casted pointer to the start of the transfer data buffer</li>
</ul>
</dd>
</dl>
<p>This convenience function is here to remind you that the control setup occupies the first 8 bytes of the transfer data buffer. Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</p>


</dd>
<dt id="libusb_fill_control_setup"><a name="libusb_fill_control_setup,ptr.cuchar,uint8,uint8,uint16,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_control_setup</span><span class="Other">(</span><span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">bmRequestType</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                               <span class="Identifier">bRequest</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">wValue</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">wIndex</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                               <span class="Identifier">wLength</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">buffer</span></tt> - Buffer to output the setup packet into. This pointer must 
           be aligned to at least 2 bytes boundary</p>
<p><tt class="docutils literal"><span class="pre">bmRequestType</span></tt> - See the <cite>bmRequestType</cite> field of 
           <cite>libusb_control_setup</cite> <tt class="docutils literal"><span class="pre">bRequest</span></tt> - See the <cite>bRequest</cite> field of <cite>libusb_control_setup</cite> <tt class="docutils literal"><span class="pre">wValue</span></tt> - See the <cite>wValue</cite> field of <cite>libusb_control_setup</cite> <tt class="docutils literal"><span class="pre">wIndex</span></tt> - See the <cite>wIndex</cite> field of <cite>libusb_control_setup</cite> <tt class="docutils literal"><span class="pre">wLength</span></tt> - See the <cite>wLength</cite> field of <cite>libusb_control_setup</cite></p>
</dd>
</dl>
<p>The <cite>wIndex</cite>, <cite>wValue</cite> and <cite>wLength</cite> values should be given in host-endian byte order.</p>


</dd>
<dt id="libusb_alloc_transfer"><a name="libusb_alloc_transfer,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_alloc_transfer</span><span class="Other">(</span><span class="Identifier">iso_packets</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_alloc_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a libusb transfer with a specified number of isochronous packet descriptors.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">iso_packets</span></tt> - Number of isochronous packet descriptors to allocate</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>a newly allocated transfer, or nil on error</li>
</ul>
</dd>
</dl>
<p>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <cite>libusb_free_transfer()</cite>. Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</p>
<p>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the num_iso_packets and type fields accordingly.</p>
<p>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, num_iso_packets is 0 and that type is set appropriately.</p>


</dd>
<dt id="libusb_submit_transfer"><a name="libusb_submit_transfer,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_submit_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_submit_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Submit a transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to submit</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success,</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR_BUSY</cite> if the transfer has already been submitted</li>
<li><cite>LIBUSB_ERROR_NOT_SUPPORTED</cite> if the transfer flags are not supported 
           by the operating system</li>
<li><cite>LIBUSB_ERROR</cite> codes for other failures</li>
</ul>
</dd>
</dl>
<p>This function will fire off the USB transfer and then return immediately.</p>


</dd>
<dt id="libusb_cancel_transfer"><a name="libusb_cancel_transfer,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_cancel_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_cancel_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Asynchronously cancel a previously submitted transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to cancel</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR_NOT_FOUND</cite> if the transfer is already complete or 
           cancelled</li>
<li><cite>LIBUSB_ERROR</cite> codes for other failures</li>
</ul>
</dd>
</dl>
<p>This function returns immediately, but this does not indicate cancellation is complete. Your callback function will be invoked at some later time with a transfer status of <cite>LIBUSB_TRANSFER_CANCELLED</cite>.</p>


</dd>
<dt id="libusb_free_transfer"><a name="libusb_free_transfer,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_free_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free a transfer structure.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to free</dd>
</dl>
<p>This should be called for all transfers allocated with <cite>libusb_alloc_transfer()</cite>. If the <cite>LIBUSB_TRANSFER_FREE_BUFFER</cite> flag is set and the transfer buffer is not nil, this function will also free the transfer buffer using the standard system memory allocator.</p>
<p>It is legal to call this function with a nil transfer. In this case, the function will simply return safely. It is not legal to free an active transfer (one which has been submitted and has not yet completed).</p>


</dd>
<dt id="libusb_transfer_set_stream_id"><a name="libusb_transfer_set_stream_id,ptr.libusb_transfer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_transfer_set_stream_id</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                                   <span class="Identifier">stream_id</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_transfer_set_stream_id&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set a transfers bulk stream id.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to set the stream id for <tt class="docutils literal"><span class="pre">stream_id</span></tt> - The stream id to set</dd>
</dl>
<p>Note users are advised to use <cite>libusb_fill_bulk_stream_transfer()</cite> instead of calling this function directly.</p>


</dd>
<dt id="libusb_transfer_get_stream_id"><a name="libusb_transfer_get_stream_id,ptr.libusb_transfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_transfer_get_stream_id</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_transfer_get_stream_id&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get a transfers bulk stream id.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to get the stream id for</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the stream id for the transfer</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_fill_control_transfer"><a name="libusb_fill_control_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,ptr.cuchar,libusb_transfer_cb_fn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_control_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                                  <span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                  <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                                  <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span><span class="Other">;</span> 
                                  <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the required <cite>libusb_transfer</cite> fields for a control transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to populate <tt class="docutils literal"><span class="pre">dev_handle</span></tt> - Handle of the device that will handle the transfer</p>
<p><tt class="docutils literal"><span class="pre">buffer</span></tt> - Data buffer. If provided, this function will interpret 
           the first 8 bytes as a setup packet and infer the transfer 
           length from that. This pointer must be aligned to at least 2 
           bytes boundary. <tt class="docutils literal"><span class="pre">callback</span></tt> - Callback function to be invoked on transfer completion <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to callback function <tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout for the transfer in milliseconds</p>
</dd>
</dl>
<p>If you pass a transfer buffer to this function, the first 8 bytes will be interpreted as a control setup packet, and the wLength field will be used to automatically populate the <cite>length</cite> field of the transfer. Therefore the recommended approach is:</p>
<ul class="simple"><li>Allocate a suitably sized data buffer (including space for control setup)</li>
<li>Call <cite>libusb_fill_control_setup()</cite></li>
<li>If this is a host-to-device transfer with a data stage, put the data in place after the setup packet</li>
<li>Call this function</li>
<li>Call <cite>libusb_submit_transfer()</cite></li>
</ul>
<p>It is also legal to pass a NULL buffer to this function, in which case this function will not attempt to populate the length field. Remember that you must then populate the buffer and length fields later.</p>


</dd>
<dt id="libusb_fill_bulk_transfer"><a name="libusb_fill_bulk_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_bulk_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                               <span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                               <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                               <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span><span class="Other">;</span> 
                               <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the required <cite>libusb_transfer</cite> fields for a bulk transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to populate <tt class="docutils literal"><span class="pre">dev_handle</span></tt> - Handle of the device that will handle the transfer <tt class="docutils literal"><span class="pre">endpoint</span></tt> - Address of the endpoint where this transfer will be sent <tt class="docutils literal"><span class="pre">buffer</span></tt> - Data buffer <tt class="docutils literal"><span class="pre">length</span></tt> - Length of data buffer <tt class="docutils literal"><span class="pre">callback</span></tt> - Callback function to be invoked on transfer completion <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to callback function <tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout for the transfer in milliseconds</dd>
</dl>


</dd>
<dt id="libusb_fill_bulk_stream_transfer"><a name="libusb_fill_bulk_stream_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,uint32,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_bulk_stream_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                                      <span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                      <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">stream_id</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> 
                                      <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                      <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span><span class="Other">;</span> 
                                      <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the required <cite>libusb_transfer</cite> fields for a bulk transfer using bulk streams.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to populate <tt class="docutils literal"><span class="pre">dev_handle</span></tt> - Handle of the device that will handle the transfer <tt class="docutils literal"><span class="pre">endpoint address</span></tt> - Of the endpoint where this transfer will be sent <tt class="docutils literal"><span class="pre">stream_id</span></tt> - Bulk stream id for this transfer <tt class="docutils literal"><span class="pre">buffer</span></tt> - Data buffer <tt class="docutils literal"><span class="pre">length</span></tt> - Length of data buffer <tt class="docutils literal"><span class="pre">callback</span></tt> - Callback function to be invoked on transfer completion <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to callback function <tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout for the transfer in milliseconds</dd>
</dl>


</dd>
<dt id="libusb_fill_interrupt_transfer"><a name="libusb_fill_interrupt_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,libusb_transfer_cb_fn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_interrupt_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                                    <span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                    <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                                    <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                    <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span><span class="Other">;</span> 
                                    <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the required <cite>libusb_transfer</cite> fields for an interrupt transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to populate <tt class="docutils literal"><span class="pre">dev_handle</span></tt> - Handle of the device that will handle the transfer <tt class="docutils literal"><span class="pre">endpoint</span></tt> - Address of the endpoint where this transfer will be sent <tt class="docutils literal"><span class="pre">buffer</span></tt> - Data buffer <tt class="docutils literal"><span class="pre">length</span></tt> - Length of data buffer <tt class="docutils literal"><span class="pre">callback</span></tt> - Callback function to be invoked on transfer completion <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to callback function <tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout for the transfer in milliseconds</dd>
</dl>


</dd>
<dt id="libusb_fill_iso_transfer"><a name="libusb_fill_iso_transfer,ptr.libusb_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,cint,libusb_transfer_cb_fn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_fill_iso_transfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
                              <span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                              <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                              <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">num_iso_packets</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                              <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">libusb_transfer_cb_fn</span><span class="Other">;</span> 
                              <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the required <cite>libusb_transfer</cite> fields for an isochronous transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - The transfer to populate <tt class="docutils literal"><span class="pre">dev_handle</span></tt> - Handle of the device that will handle the transfer <tt class="docutils literal"><span class="pre">endpoint</span></tt> - Address of the endpoint where this transfer will be sent <tt class="docutils literal"><span class="pre">buffer</span></tt> - Data buffer <tt class="docutils literal"><span class="pre">length</span></tt> - Length of data buffer <tt class="docutils literal"><span class="pre">num_iso_packets</span></tt> - The number of isochronous packets <tt class="docutils literal"><span class="pre">callback</span></tt> - Callback function to be invoked on transfer completion <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to callback function <tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout for the transfer in milliseconds</dd>
</dl>


</dd>
<dt id="libusb_set_iso_packet_lengths"><a name="libusb_set_iso_packet_lengths,ptr.libusb_transfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_iso_packet_lengths</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to set the length of all packets in an isochronous transfer, based on the num_iso_packets field in the transfer structure.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">transfer</span></tt> - A transfer</p>
<p><tt class="docutils literal"><span class="pre">length</span></tt> - The length to set in each isochronous packet descriptor 
           (see <cite>libusb_get_max_packet_size()</cite></p>
</dd>
</dl>


</dd>
<dt id="libusb_get_iso_packet_buffer"><a name="libusb_get_iso_packet_buffer,ptr.libusb_transfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_iso_packet_buffer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> <span class="Identifier">packet</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - A transfer <tt class="docutils literal"><span class="pre">packet</span></tt> - The packet to return the address of</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the base address of the packet buffer inside the transfer buffer</li>
<li>nil if the packet does not exist</li>
</ul>
</dd>
</dl>
<p>This is a thorough function which loops through all preceding packets, accumulating their lengths to find the position of the specified packet. Typically you will assign equal lengths to each packet in the transfer, and hence the above method is sub-optimal. You may wish to use <cite>libusb_get_iso_packet_buffer_simple()</cite> instead.</p>


</dd>
<dt id="libusb_get_iso_packet_buffer_simple"><a name="libusb_get_iso_packet_buffer_simple,ptr.libusb_transfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_iso_packet_buffer_simple</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_transfer</span><span class="Other">;</span> 
    <span class="Identifier">packet</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
<p>Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size.</p>
<p>This function relies on the assumption that every packet within the transfer is of identical size to the first packet. Calculating the location of the packet buffer is then just a simple calculation:</p>
<blockquote><p>&lt;tt&gt;buffer + (packet_size * packet)&lt;/tt&gt;</p></blockquote>
<p>Do not use this function on transfers other than those that have identical packet lengths for each packet.</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">transfer</span></tt> - A transfer <tt class="docutils literal"><span class="pre">packet</span></tt> - The packet to return the address of</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>the base address of the packet buffer inside the transfer buffer</li>
<li>nil if the packet does not exist (see <cite>libusb_get_iso_packet_buffer()</cite>).</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_control_transfer"><a name="libusb_control_transfer,ptr.libusb_device_handle,libusb_endpoint_direction,libusb_standard_request,uint16,uint16,ptr.cuchar,uint16,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_control_transfer</span><span class="Other">(</span><span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                             <span class="Identifier">request_type</span><span class="Other">:</span> <span class="Identifier">libusb_endpoint_direction</span><span class="Other">;</span> 
                             <span class="Identifier">bRequest</span><span class="Other">:</span> <span class="Identifier">libusb_standard_request</span><span class="Other">;</span> <span class="Identifier">wValue</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                             <span class="Identifier">wIndex</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">wLength</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                             <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_control_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB control transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev_handle</span></tt> - A handle for the device to communicate with <tt class="docutils literal"><span class="pre">bmRequestType</span></tt> - The request type field for the setup packet <tt class="docutils literal"><span class="pre">bRequest</span></tt> - The request field for the setup packet <tt class="docutils literal"><span class="pre">wValue</span></tt> - The value field for the setup packet <tt class="docutils literal"><span class="pre">wIndex</span></tt> - The index field for the setup packet</p>
<p><tt class="docutils literal"><span class="pre">data</span></tt> - A suitably-sized data buffer for either input or output 
           (depending on direction bits within bmRequestType)</p>
<p><tt class="docutils literal"><span class="pre">wLength</span></tt> - The length field for the setup packet. The data buffer 
           should be at least this size</p>
<p><tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout (in millseconds) that this function should wait 
           before giving up due to no response being received. For an 
           unlimited timeout, use value 0</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>on success, the number of bytes actually transferred</li>
<li><cite>LIBUSB_ERROR_TIMEOUT</cite> if the transfer timed out</li>
<li><cite>LIBUSB_ERROR_PIPE</cite> if the control request was not supported by the 
           device</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the bmRequestType field of the setup packet. The wValue, wIndex and wLength fields values should be given in host-endian byte order.</p>


</dd>
<dt id="libusb_bulk_transfer"><a name="libusb_bulk_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_bulk_transfer</span><span class="Other">(</span><span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                          <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                          <span class="Identifier">actual_length</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_bulk_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB bulk transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev_handle</span></tt> - A handle for the device to communicate with <tt class="docutils literal"><span class="pre">endpoint</span></tt> - The address of a valid endpoint to communicate with</p>
<p><tt class="docutils literal"><span class="pre">data</span></tt> - A suitably-sized data buffer for either input or output 
           (depending on endpoint)</p>
<p><tt class="docutils literal"><span class="pre">length</span></tt> - For bulk writes, the number of bytes from data to be 
           sent. For bulk reads, the maximum number of bytes to receive 
           into the data buffer</p>
<p><tt class="docutils literal"><span class="pre">transferred</span></tt> - Output location for the number of bytes actually 
           transferred</p>
<p><tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout (in millseconds) that this function should wait 
           before giving up due to no response being received. For an 
           unlimited timeout, use value 0</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success (and populates transferred)</li>
<li><cite>LIBUSB_ERROR_TIMEOUT</cite> if the transfer timed out (and populates 
           transferred)</li>
<li><cite>LIBUSB_ERROR_PIPE</cite> if the endpoint halted</li>
<li><cite>LIBUSB_ERROR_OVERFLOW</cite> if the device offered more data, see Packets 
           and overflows</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the direction bits of the endpoint address. For bulk reads, the length field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the transferred output parameter.</p>
<p>You should also check the transferred parameter for bulk writes. Not all of the data may have been written. Also check transferred when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</p>


</dd>
<dt id="libusb_interrupt_transfer"><a name="libusb_interrupt_transfer,ptr.libusb_device_handle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_interrupt_transfer</span><span class="Other">(</span><span class="Identifier">dev_handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                               <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                               <span class="Identifier">actual_length</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_interrupt_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB interrupt transfer.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">dev_handle</span></tt> - A handle for the device to communicate with <tt class="docutils literal"><span class="pre">endpoint</span></tt> - The address of a valid endpoint to communicate with</p>
<p><tt class="docutils literal"><span class="pre">data</span></tt> - A suitably-sized data buffer for either input or output 
           (depending on endpoint)</p>
<p><tt class="docutils literal"><span class="pre">length</span></tt> - For bulk writes, the number of bytes from data to be 
           sent. For bulk reads, the maximum number of bytes to receive 
           into the data buffer</p>
<p><tt class="docutils literal"><span class="pre">actual_length</span></tt> - Output location for the number of bytes actually 
           transferred</p>
<p><tt class="docutils literal"><span class="pre">timeout</span></tt> - Timeout (in millseconds) that this function should wait 
           before giving up due to no response being received. For an 
           unlimited timeout, use value 0</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success (and populates transferred)</li>
<li><cite>LIBUSB_ERROR_TIMEOUT</cite> if the transfer timed out</li>
<li><cite>LIBUSB_ERROR_PIPE</cite> if the endpoint halted</li>
<li><cite>LIBUSB_ERROR_OVERFLOW</cite> if the device offered more data, see Packets 
           and overflows</li>
<li><cite>LIBUSB_ERROR_NO_DEVICE</cite> if the device has been disconnected</li>
<li><cite>LIBUSB_ERROR</cite> codes on other errors</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the direction bits of the endpoint address. For interrupt reads, the length field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the transferred output parameter.</p>
<p>You should also check the transferred parameter for interrupt writes. Not all of the data may have been written. Also check transferred when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</p>
<p>The default endpoint bInterval value is used as the polling interval.</p>


</dd>
<dt id="libusb_get_descriptor"><a name="libusb_get_descriptor,ptr.libusb_device_handle,uint8,uint8,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_descriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> <span class="Identifier">desc_type</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                           <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a descriptor from the default control pipe.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">desc_type</span></tt> - The descriptor type, see <cite>libusb_descriptor_type</cite> <tt class="docutils literal"><span class="pre">desc_index</span></tt> - The index of the descriptor to retrieve <tt class="docutils literal"><span class="pre">data</span></tt> - Output buffer for descriptor <tt class="docutils literal"><span class="pre">length</span></tt> - Size of data buffer</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>number of bytes returned in data</li>
<li><cite>LIBUSB_ERROR</cite> code on failure</li>
</ul>
</dd>
</dl>
<p>This is a convenience function which formulates the appropriate control message to retrieve the descriptor.</p>


</dd>
<dt id="libusb_get_string_descriptor"><a name="libusb_get_string_descriptor,ptr.libusb_device_handle,uint8,uint16,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_string_descriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                  <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">langid</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                                  <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a descriptor from a device.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">desc_index</span></tt> - The index of the descriptor to retrieve <tt class="docutils literal"><span class="pre">langid</span></tt> - The language ID for the string descriptor <tt class="docutils literal"><span class="pre">data</span></tt> - Output buffer for descriptor <tt class="docutils literal"><span class="pre">length</span></tt> - Size of data buffer</dd>
<dt><cite>Returns</cite></dt>
<dd><ul class="simple"><li>number of bytes returned in data</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
<dt></dt>
<dd>This is a convenience function which formulates the appropriate control</dd>
</dl>
<p>message to retrieve the descriptor. The string returned is Unicode, as detailed in the USB specifications.</p>


</dd>
<dt id="libusb_get_string_descriptor_ascii"><a name="libusb_get_string_descriptor_ascii,ptr.libusb_device_handle,uint8,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_string_descriptor_ascii</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_device_handle</span><span class="Other">;</span> 
                                        <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                                        <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_string_descriptor_ascii&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a string descriptor in C style ASCII. Wrapper around <cite>libusb_get_string_descriptor()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">dev</span></tt> - A device handle <tt class="docutils literal"><span class="pre">desc_index</span></tt> - The index of the descriptor to retrieve <tt class="docutils literal"><span class="pre">data</span></tt> - Output buffer for ASCII string descriptor <tt class="docutils literal"><span class="pre">length</span></tt> - Size of data buffer</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>number of bytes returned in data</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>Uses the first language supported by the device.</p>


</dd>
<dt id="libusb_try_lock_events"><a name="libusb_try_lock_events,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_try_lock_events</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_try_lock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Attempt to acquire the event handling lock. This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 if the lock was obtained successfully</li>
<li>1 if the lock was not obtained (i.e. another thread holds the lock)</li>
</ul>
</dd>
</dl>
<p>You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly. If you stick to libusb's event handling loop functions, i.e. <cite>libusb_handle_events()</cite> then you do not need to be concerned with this locking.</p>
<p>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <cite>libusb_unlock_events()</cite> as soon as possible.</p>


</dd>
<dt id="libusb_lock_events"><a name="libusb_lock_events,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_lock_events</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_lock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Acquire the event handling lock, blocking until successful acquisition if it is contended.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
</dl>
<p>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time. You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly. If you stick to libusb's event handling loop functions (e.g. <cite>libusb_handle_events()</cite>) then you do not need to be concerned with this locking.</p>
<p>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <cite>libusb_unlock_events()</cite> as soon as possible.</p>


</dd>
<dt id="libusb_unlock_events"><a name="libusb_unlock_events,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_unlock_events</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unlock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release the lock previously acquired with <cite>libusb_try_lock_events()</cite> or <cite>libusb_lock_events()</cite>.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
</dl>
<p>Releasing this lock will wake up any threads blocked on <cite>libusb_wait_for_event()</cite>.</p>


</dd>
<dt id="libusb_event_handling_ok"><a name="libusb_event_handling_ok,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_event_handling_ok</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_event_handling_ok&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if it is still OK for this thread to be doing event handling.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>1 if event handling can start or continue</li>
<li>0 if this thread must give up the events lock</li>
</ul>
</dd>
</dl>
<p>Sometimes, libusb needs to temporarily pause all event handlers, and this is the function you should use before polling file descriptors to see if this is the case. If this function instructs your thread to give up the events lock, you should just continue the usual logic that is documented in Multi-threaded applications and asynchronous I/O. On the next iteration, your thread will fail to obtain the events lock, and will hence become an event waiter.</p>
<p>This function should be called while the events lock is held: you don't need to worry about the results of this function if your thread is not the current event handler.</p>


</dd>
<dt id="libusb_event_handler_active"><a name="libusb_event_handler_active,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_event_handler_active</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_event_handler_active&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if an active thread is handling events (i.e. if anyone is holding the event handling lock).<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>1 if a thread is handling events,</li>
<li>0 if there are no threads currently handling events.</li>
</ul>
</dd>
</dl>


</dd>
<dt id="libusb_lock_event_waiters"><a name="libusb_lock_event_waiters,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_lock_event_waiters</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_lock_event_waiters&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Acquire the event waiters lock.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
</dl>
<p>This lock is designed to be obtained under the situation where you want to be aware when events are completed, but some other thread is event handling so calling libusb_handle_events() is not allowed. You then obtain this lock, re-check that another thread is still handling events, then call <cite>libusb_wait_for_event()</cite>.</p>
<p>You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly, and may potentially be handling events from 2 threads simultaenously. If you stick to libusb's event handling loop functions (e.g. <cite>libusb_handle_events()</cite>) then you do not need to be concerned with this locking.</p>


</dd>
<dt id="libusb_unlock_event_waiters"><a name="libusb_unlock_event_waiters,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_unlock_event_waiters</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unlock_event_waiters&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release the event waiters lock.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</dd>
</dl>


</dd>
<dt id="libusb_wait_for_event"><a name="libusb_wait_for_event,ptr.libusb_context,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_wait_for_event</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_wait_for_event&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Wait for another thread to signal completion of an event.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">tv</span></tt> - Maximum timeout for this blocking function. A nil value 
           indicates unlimited timeout.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 after a transfer completes or another thread stops event handling</li>
<li>1 if the timeout expired</li>
</ul>
</dd>
</dl>
<p>Must be called with the event waiters lock held, see <cite>libusb_lock_event_waiters()</cite>. This function will block until any of the following conditions are met:</p>
<blockquote><p><ol class="simple"><li>The timeout expires</li>
<li>A transfer completes</li>
<li>thread releases the event handling lock through <cite>libusb_unlock_events()</cite></li>
</ol>
</p></blockquote>
<p>Condition 1 is obvious. Condition 2 unblocks your thread after the callback for the transfer has completed. Condition 3 is important because it means that the thread that was previously handling events is no longer doing so, so if any events are to complete, another thread needs to step up and start event handling.</p>
<p>This function releases the event waiters lock before putting your thread to sleep, and reacquires the lock as it is being woken up.</p>


</dd>
<dt id="libusb_handle_events_timeout_completed"><a name="libusb_handle_events_timeout_completed,ptr.libusb_context,ptr.timeval,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_handle_events_timeout_completed</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
    <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">;</span> <span class="Identifier">completed</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_timeout_completed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">tv</span></tt> - The maximum time to block waiting for events, or an all zero 
           timeval struct for non-blocking mode <tt class="docutils literal"><span class="pre">completed</span></tt> - Pointer to completion integer to check, or nil</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>libusb determines &quot;pending events&quot; by checking if any timeouts have expired and by checking the set of file descriptors for activity.</p>
<p>If a zero timeval is passed, this function will handle any already-pending events and then immediately return in non-blocking style. IF a non-zero timeval is passed and no events are currently pending, this function will block waiting for events to handle up until the specified timeout. If an event arrives or a signal is raised, this function will return early. If the parameter completed is not nil then after obtaining the event handling lock this function will return immediately if the integer pointed to is not</p>
<p>0. This allows for race free waiting for the completion of a specific transfer.</p>


</dd>
<dt id="libusb_handle_events_completed"><a name="libusb_handle_events_completed,ptr.libusb_context,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_handle_events_completed</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">completed</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_completed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events in blocking mode.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> the context to operate on, or nil for the default context <tt class="docutils literal"><span class="pre">completed</span></tt> - Pointer to completion integer to check, or nil</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> codec on failure</li>
</ul>
</dd>
</dl>
<p>Like <cite>libusb_handle_events()</cite>, with the addition of a completed parameter to allow for race free waiting for the completion of a specific transfer. See <cite>libusb_handle_events_timeout_completed()</cite> for details on the completed parameter.</p>


</dd>
<dt id="libusb_handle_events_locked"><a name="libusb_handle_events_locked,ptr.libusb_context,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_handle_events_locked</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_locked&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events by polling file descriptors, without checking if any other threads are already doing so.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or NULL for the default context</p>
<p><tt class="docutils literal"><span class="pre">tv</span></tt> - The maximum time to block waiting for events, or zero for 
           non-blocking mode</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 on success</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>Must be called with the event lock held, see <cite>libusb_lock_events()</cite>. This function is designed to be called under the situation where you have taken the event lock and are calling <cite>poll()/select()</cite> directly on libusb's file descriptors (as opposed to using <cite>libusb_handle_events()</cite> or similar). You detect events on libusb's descriptors, so you then call this function with a zero timeout value (while still holding the event lock).</p>


</dd>
<dt id="libusb_pollfds_handle_timeouts"><a name="libusb_pollfds_handle_timeouts,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_pollfds_handle_timeouts</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_pollfds_handle_timeouts&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determines whether your application must apply special timing considerations when monitoring libusb's file descriptors.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or NULL for the default context</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 if you must call into libusb at times determined by 
           <cite>libusb_get_next_timeout()</cite>,</li>
<li>1 if all timeout events are handled internally or through regular 
           activity on the file descriptors</li>
</ul>
</dd>
</dl>
<p>This function is only useful for applications which retrieve and poll libusb's file descriptors in their own main loop (The more advanced option). Ordinarily, libusb's event handler needs to be called into at specific moments in time (in addition to times when there is activity on the file descriptor set). The usual approach is to use <cite>libusb_get_next_timeout()</cite> to learn about when the next timeout occurs, and to adjust your <cite>poll()/select()</cite> timeout accordingly so that you can make a call into the library at that time.</p>
<p>Some platforms supported by libusb do not come with this baggage - any events relevant to timing will be represented by activity on the file descriptor set, and <cite>libusb_get_next_timeout()</cite> will always return 0. This function allows you to detect whether you are running on such a platform.</p>


</dd>
<dt id="libusb_get_next_timeout"><a name="libusb_get_next_timeout,ptr.libusb_context,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_next_timeout</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_next_timeout&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine the next internal timeout that libusb needs to handle.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or nil for the default context</p>
<p><tt class="docutils literal"><span class="pre">tv</span></tt> - Output location for a relative time against the current clock 
           in which libusb must be called into in order to process 
           timeout events</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>0 if there are no pending timeouts</li>
<li>1 if a timeout was returned</li>
<li><cite>LIBUSB_ERROR_OTHER</cite> on failure</li>
</ul>
</dd>
</dl>
<p>You only need to use this function if you are calling <cite>poll()</cite> or <cite>select()</cite> or similar on libusb's file descriptors yourself - you do not need to use it if you are calling <cite>libusb_handle_events()</cite> or a variant directly.</p>
<p>You should call this function in your main loop in order to determine how long to wait for select() or poll() to return results. libusb needs to be called into at this timeout, so you should use it as an upper bound on your <cite>select()</cite> or <cite>poll()</cite> call.</p>
<p>When the timeout has expired, call into <cite>libusb_handle_events_timeout()</cite> (perhaps in non-blocking mode) so that libusb can handle the timeout.</p>
<p>This function may return 1 (success) and an all-zero timeval. If this is the case, it indicates that libusb has a timeout that has already expired so you should call libusb_handle_events_timeout() or similar immediately. A return code of 0 indicates that there are no pending timeouts.</p>
<p>On some platforms, this function will always returns 0 (no pending timeouts). See Notes on time-based events.</p>


</dd>
<dt id="libusb_get_pollfds"><a name="libusb_get_pollfds,ptr.libusb_context"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_get_pollfds</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_pollfd</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_pollfds&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or NULL for the default context</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li>a nil-terminated list of <cite>libusb_pollfd</cite> structures</li>
<li>nil on error</li>
<li>nil on platforms where the functionality is not available</li>
</ul>
</dd>
</dl>
<p>The returned list is NULL-terminated and should be freed with free() when done. The actual list contents must not be touched. As file descriptors are a Unix-specific concept, this function is not available on Windows and will always return nil.</p>


</dd>
<dt id="libusb_set_pollfd_notifiers"><a name="libusb_set_pollfd_notifiers,ptr.libusb_context,libusb_pollfd_added_cb,libusb_pollfd_removed_cb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_set_pollfd_notifiers</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
                                 <span class="Identifier">added_cb</span><span class="Other">:</span> <span class="Identifier">libusb_pollfd_added_cb</span><span class="Other">;</span> 
                                 <span class="Identifier">removed_cb</span><span class="Other">:</span> <span class="Identifier">libusb_pollfd_removed_cb</span><span class="Other">;</span> 
                                 <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_pollfd_notifiers&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Register notification functions for file descriptor additions/removals.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - The context to operate on, or NULL for the default context <tt class="docutils literal"><span class="pre">added_cb</span></tt> - Pointer to function for addition notifications <tt class="docutils literal"><span class="pre">removed_cb</span></tt> - Pointer to function for removal notifications</p>
<p><tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to be passed back to callbacks (useful for 
           passing context information).</p>
</dd>
</dl>
<p>These functions will be invoked for every new or removed file descriptor that libusb uses as an event source. To remove notifiers, pass nil values for the function pointers.</p>
<p>Note that file descriptors may have been added even before you register these notifiers (e.g. at <cite>libusb_init()</cite> time). Additionally, note that the removal notifier may be called during <cite>libusb_exit()</cite> (e.g. when it is closing file descriptors that were opened and added to the poll set at <cite>libusb_init()</cite> time). If you don't want this, remove the notifiers immediately before calling libusb_exit().</p>


</dd>
<dt id="libusb_hotplug_register_callback"><a name="libusb_hotplug_register_callback,ptr.libusb_context,libusb_hotplug_event,libusb_hotplug_flag,cint,cint,cint,libusb_hotplug_callback_fn,pointer,ptr.libusb_hotplug_callback_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_hotplug_register_callback</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
                                      <span class="Identifier">events</span><span class="Other">:</span> <span class="Identifier">libusb_hotplug_event</span><span class="Other">;</span> 
                                      <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">libusb_hotplug_flag</span><span class="Other">;</span> 
                                      <span class="Identifier">vendor_id</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">product_id</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                      <span class="Identifier">dev_class</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                      <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">libusb_hotplug_callback_fn</span><span class="Other">;</span> 
                                      <span class="Identifier">user_data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_hotplug_callback_handle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_hotplug_register_callback&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Register a hotplug callback function.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">ctx</span></tt> - Context to register this callback with</p>
<p><tt class="docutils literal"><span class="pre">events</span></tt> - Bitwise or of events that will trigger this callback 
           (see <cite>libusb_hotplug_event</cite>) <tt class="docutils literal"><span class="pre">flags</span></tt> - Hotplug callback flags (see <cite>libusb_hotplug_flag</cite>) <tt class="docutils literal"><span class="pre">vendor_id</span></tt> - The vendor id to match or <cite>LIBUSB_HOTPLUG_MATCH_ANY</cite> <tt class="docutils literal"><span class="pre">product_id</span></tt> - The product id to match or <cite>LIBUSB_HOTPLUG_MATCH_ANY</cite> <tt class="docutils literal"><span class="pre">dev_class</span></tt> - The device class to match or <cite>LIBUSB_HOTPLUG_MATCH_ANY</cite> <tt class="docutils literal"><span class="pre">cb_fn</span></tt> - The function to be invoked on a matching event/device <tt class="docutils literal"><span class="pre">user_data</span></tt> - User data to pass to the callback function</p>
<p><tt class="docutils literal"><span class="pre">handle</span></tt> - Pointer to store the handle of the allocated callback 
           (can be nil).</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Returns</span></tt></dt>
<dd><ul class="simple"><li><cite>LIBUSB_SUCCESS</cite> on success</li>
<li><cite>LIBUSB_ERROR</cite> codes on failure</li>
</ul>
</dd>
</dl>
<p>Register a callback with the libusb_context. The callback will fire when a matching event occurs on a matching device. The callback is armed until either it is deregistered with <cite>libusb_hotplug_deregister_callback()</cite> or the supplied callback returns 1 to indicate it is finished processing events.</p>
<p>If the <cite>LIBUSB_HOTPLUG_ENUMERATE</cite> is passed the callback will be called with <cite>LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED</cite> for all devices already plugged into the machine. Note that libusb modifies its internal device list from a separate thread, while calling hotplug callbacks from <cite>libusb_handle_events()</cite>, so it is possible for a device to already be present on, or removed from, its internal device list, while the hotplug callbacks still need to be dispatched. This means that when using <cite>LIBUSB_HOTPLUG_ENUMERATE</cite>, your callback may be called twice for the arrival of the same device, once from <cite>libusb_hotplug_register_callback()</cite> and once from <cite>libusb_handle_events()</cite>; and/or your callback may be called for the removal of a device for which an arrived call was never made.</p>


</dd>
<dt id="libusb_hotplug_deregister_callback"><a name="libusb_hotplug_deregister_callback,ptr.libusb_context,libusb_hotplug_callback_handle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusb_hotplug_deregister_callback</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">libusb_context</span><span class="Other">;</span> 
                                        <span class="Identifier">handle</span><span class="Other">:</span> <span class="Identifier">libusb_hotplug_callback_handle</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_hotplug_deregister_callback&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Deregisters a hotplug callback.<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">Parameters</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">ctx</span></tt> - Context this callback is registered with <tt class="docutils literal"><span class="pre">handle</span></tt> - The handle of the callback to deregister.</dd>
</dl>
<p>Deregister a callback from a libusb_context. This function is safe to call from within a hotplug callback.</p>


</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<dt id="libusb_le16_to_cpu"><a name="libusb_le16_to_cpu.t,uint16"></a><pre><span class="Keyword">template</span> <span class="Identifier">libusb_le16_to_cpu</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint16</span></pre></dt>
<dd>


</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-01-17 23:50:16 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
